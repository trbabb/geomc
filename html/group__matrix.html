<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geomc: Matrix</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">geomc<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A c++ linear algebra template library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Matrix<div class="ingroups"><a class="el" href="group__linalg.html">Linalg</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Matrix-related functions and classes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_diag_matrix.html">DiagMatrix&lt; T, M, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with nonzero elements only along the main diagonal.  <a href="classgeom_1_1_diag_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_matrix_handle.html">MatrixHandle&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic matrix class which can hold references to all other matrix types.  <a href="classgeom_1_1_matrix_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_permutation_matrix.html">PermutationMatrix&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix which, by multiplication, permutes the rows or columns of another matrix.  <a href="classgeom_1_1_permutation_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix&lt; T, M, N, Lyt, P &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic matrix with <code>M x N</code> elements.  <a href="classgeom_1_1_simple_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaddebe98a06082a435254a640ba53e28c" id="r_gaddebe98a06082a435254a640ba53e28c"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gaddebe98a06082a435254a640ba53e28c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaddebe98a06082a435254a640ba53e28c">mtx_aliases_storage</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gaddebe98a06082a435254a640ba53e28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e38179d0cfe99996eede7017e18b9e3" id="r_ga8e38179d0cfe99996eede7017e18b9e3"><td class="memTemplParams" colspan="2"><a id="ga8e38179d0cfe99996eede7017e18b9e3" name="ga8e38179d0cfe99996eede7017e18b9e3"></a>
template&lt;typename T , index_t N&gt; </td></tr>
<tr class="memitem:ga8e38179d0cfe99996eede7017e18b9e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mtx_aliases_storage</b> (const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; &amp;a, const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:ga8e38179d0cfe99996eede7017e18b9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4cc58853d04688d1bf2dc0ed7feb78b" id="r_gaf4cc58853d04688d1bf2dc0ed7feb78b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gaf4cc58853d04688d1bf2dc0ed7feb78b"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf4cc58853d04688d1bf2dc0ed7feb78b">mul</a> (Matrix *into, const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gaf4cc58853d04688d1bf2dc0ed7feb78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf0b654b9d8fe59a684862d05897af6" id="r_gadcf0b654b9d8fe59a684862d05897af6"><td class="memTemplParams" colspan="2"><a id="gadcf0b654b9d8fe59a684862d05897af6" name="gadcf0b654b9d8fe59a684862d05897af6"></a>
template&lt;typename Md , typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gadcf0b654b9d8fe59a684862d05897af6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_matrix_multipliable.html">detail::MatrixMultipliable</a>&lt; Ma, Mb &gt;::valanddetail::_ImplMtxResult&lt; Ma, Mb, Md &gt;::agreement==detail::MTX_RESULT_MATCH, Md &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mul</b> (Md *into, const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gadcf0b654b9d8fe59a684862d05897af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0484c4fd6e6582fcdba6354a608ff317" id="r_ga0484c4fd6e6582fcdba6354a608ff317"><td class="memTemplParams" colspan="2">template&lt;typename Md , typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga0484c4fd6e6582fcdba6354a608ff317"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_matrix_multipliable.html">detail::MatrixMultipliable</a>&lt; Ma, Mb &gt;::valanddetail::_ImplMtxResult&lt; Ma, Mb, Md &gt;::agreement==detail::MTX_RESULT_MATCH, Md &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0484c4fd6e6582fcdba6354a608ff317">mul_acc</a> (Md *into, const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga0484c4fd6e6582fcdba6354a608ff317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37c0fecbc60b92f4e8a2141520a43ed8" id="r_ga37c0fecbc60b92f4e8a2141520a43ed8"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga37c0fecbc60b92f4e8a2141520a43ed8"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga37c0fecbc60b92f4e8a2141520a43ed8">mul</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga37c0fecbc60b92f4e8a2141520a43ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee63752e74aab0b26ec7721b7f1fc729" id="r_gaee63752e74aab0b26ec7721b7f1fc729"><td class="memTemplParams" colspan="2"><a id="gaee63752e74aab0b26ec7721b7f1fc729" name="gaee63752e74aab0b26ec7721b7f1fc729"></a>
template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gaee63752e74aab0b26ec7721b7f1fc729"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_matrix_multipliable.html">detail::MatrixMultipliable</a>&lt; Ma, Mb &gt;::val, typenamedetail::_ImplMtxMul&lt; Ma, Mb &gt;::return_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mul</b> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gaee63752e74aab0b26ec7721b7f1fc729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a3dae80c0e4892f8078eab7570be593" id="r_ga2a3dae80c0e4892f8078eab7570be593"><td class="memTemplParams" colspan="2"><a id="ga2a3dae80c0e4892f8078eab7570be593" name="ga2a3dae80c0e4892f8078eab7570be593"></a>
template&lt;typename T , index_t M, index_t N, MatrixLayout Lyt, <a class="el" href="group__storage.html#ga1fe6a0f4b7ba39c90d3d765ca72c3097">StoragePolicy</a> P&gt; </td></tr>
<tr class="memitem:ga2a3dae80c0e4892f8078eab7570be593"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; M *N==0orM==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (<a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix</a>&lt; T, M, N, Lyt, P &gt; *into, const <a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix</a>&lt; T, M, N, Lyt, P &gt; &amp;m)</td></tr>
<tr class="separator:ga2a3dae80c0e4892f8078eab7570be593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8607b52b5602a3a36d694b83684e8b01" id="r_ga8607b52b5602a3a36d694b83684e8b01"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga8607b52b5602a3a36d694b83684e8b01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8607b52b5602a3a36d694b83684e8b01">transpose</a> (Matrix1 *into, const Matrix2 &amp;m)</td></tr>
<tr class="separator:ga8607b52b5602a3a36d694b83684e8b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362eb555677e2b7a623b04e3fafce37d" id="r_ga362eb555677e2b7a623b04e3fafce37d"><td class="memTemplParams" colspan="2"><a id="ga362eb555677e2b7a623b04e3fafce37d" name="ga362eb555677e2b7a623b04e3fafce37d"></a>
template&lt;typename Md , typename Mx &gt; </td></tr>
<tr class="memitem:ga362eb555677e2b7a623b04e3fafce37d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_is_matrix.html">detail::IsMatrix</a>&lt; Md &gt;::valanddetail::IsMatrix&lt; Mx &gt;::valand(Md::ROWDIM==Mx::COLDIMorMd::ROWDIM *Mx::COLDIM==0) and(Md::COLDIM==Mx::ROWDIMorMd::COLDIM *Mx::ROWDIM==0), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (Md *into, const Mx &amp;m)</td></tr>
<tr class="separator:ga362eb555677e2b7a623b04e3fafce37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22531038b8c151d265d975efb298799c" id="r_ga22531038b8c151d265d975efb298799c"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 &gt; </td></tr>
<tr class="memitem:ga22531038b8c151d265d975efb298799c"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga22531038b8c151d265d975efb298799c">transpose</a> (const Matrix1 &amp;m)</td></tr>
<tr class="separator:ga22531038b8c151d265d975efb298799c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f61a32bbc9507bd769f2c517207f047" id="r_ga5f61a32bbc9507bd769f2c517207f047"><td class="memTemplParams" colspan="2"><a id="ga5f61a32bbc9507bd769f2c517207f047" name="ga5f61a32bbc9507bd769f2c517207f047"></a>
template&lt;typename Mx &gt; </td></tr>
<tr class="memitem:ga5f61a32bbc9507bd769f2c517207f047"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_is_matrix.html">detail::IsMatrix</a>&lt; Mx &gt;::val, typenamedetail::_ImplMtxTxpose&lt; Mx &gt;::return_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (const Mx &amp;m)</td></tr>
<tr class="separator:ga5f61a32bbc9507bd769f2c517207f047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga295757f10d10ded031d121542c91537e" id="r_ga295757f10d10ded031d121542c91537e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga295757f10d10ded031d121542c91537e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga295757f10d10ded031d121542c91537e">inv</a> (Matrix1 *into, const Matrix2 &amp;src)</td></tr>
<tr class="separator:ga295757f10d10ded031d121542c91537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb007bdd51a713b89132008a215f2a8c" id="r_gacb007bdd51a713b89132008a215f2a8c"><td class="memTemplParams" colspan="2"><a id="gacb007bdd51a713b89132008a215f2a8c" name="gacb007bdd51a713b89132008a215f2a8c"></a>
template&lt;typename Md , typename Mx &gt; </td></tr>
<tr class="memitem:gacb007bdd51a713b89132008a215f2a8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inv</b> (Md *into, const Mx &amp;src, M_ENABLE_IF((<a class="el" href="structgeom_1_1detail_1_1_matrix_dimension_match.html">detail::MatrixDimensionMatch</a>&lt; Md, Mx &gt;::isStaticMatch and(Mx::ROWDIM==Mx::COLDIM or Mx::ROWDIM *Mx::COLDIM==DYNAMIC_DIM))))</td></tr>
<tr class="separator:gacb007bdd51a713b89132008a215f2a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac0cb024cab6ab5d63b8a246e557e5b5" id="r_gaac0cb024cab6ab5d63b8a246e557e5b5"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 &gt; </td></tr>
<tr class="memitem:gaac0cb024cab6ab5d63b8a246e557e5b5"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaac0cb024cab6ab5d63b8a246e557e5b5">inv</a> (const Matrix1 &amp;m, bool *success)</td></tr>
<tr class="separator:gaac0cb024cab6ab5d63b8a246e557e5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9670fd9ba27c4df2d5bea1b6d2004ef4" id="r_ga9670fd9ba27c4df2d5bea1b6d2004ef4"><td class="memTemplParams" colspan="2"><a id="ga9670fd9ba27c4df2d5bea1b6d2004ef4" name="ga9670fd9ba27c4df2d5bea1b6d2004ef4"></a>
template&lt;typename Mx &gt; </td></tr>
<tr class="memitem:ga9670fd9ba27c4df2d5bea1b6d2004ef4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1detail_1_1___impl_mtx_inv.html">detail::_ImplMtxInv</a>&lt; Mx &gt;::return_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inv</b> (const Mx &amp;m, bool *success, M_ENABLE_IF(Mx::ROWDIM==Mx::COLDIM or Mx::ROWDIM *Mx::COLDIM==DYNAMIC_DIM))</td></tr>
<tr class="separator:ga9670fd9ba27c4df2d5bea1b6d2004ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa944b9a37e5ff0157724b7625d004674" id="r_gaa944b9a37e5ff0157724b7625d004674"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gaa944b9a37e5ff0157724b7625d004674"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa944b9a37e5ff0157724b7625d004674">add</a> (Matrix *d, const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gaa944b9a37e5ff0157724b7625d004674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3de872b81634993b79742fc2cb7b2b2" id="r_gab3de872b81634993b79742fc2cb7b2b2"><td class="memTemplParams" colspan="2"><a id="gab3de872b81634993b79742fc2cb7b2b2" name="gab3de872b81634993b79742fc2cb7b2b2"></a>
template&lt;typename Md , typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gab3de872b81634993b79742fc2cb7b2b2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_matrix_dimension_match.html">detail::MatrixDimensionMatch</a>&lt; Ma, Mb &gt;::isStaticMatchanddetail::MatrixDimensionMatch&lt; Ma, Md &gt;::isStaticMatch, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add</b> (Md *d, const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gab3de872b81634993b79742fc2cb7b2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0bdc9a1392c82fa16cda590742b442a" id="r_gad0bdc9a1392c82fa16cda590742b442a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gad0bdc9a1392c82fa16cda590742b442a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad0bdc9a1392c82fa16cda590742b442a">sub</a> (Matrix *d, const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gad0bdc9a1392c82fa16cda590742b442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ad6fc2d41092a3afca70cc284a9a35" id="r_ga52ad6fc2d41092a3afca70cc284a9a35"><td class="memTemplParams" colspan="2"><a id="ga52ad6fc2d41092a3afca70cc284a9a35" name="ga52ad6fc2d41092a3afca70cc284a9a35"></a>
template&lt;typename Md , typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga52ad6fc2d41092a3afca70cc284a9a35"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_matrix_dimension_match.html">detail::MatrixDimensionMatch</a>&lt; Ma, Mb &gt;::isStaticMatchanddetail::MatrixDimensionMatch&lt; Ma, Md &gt;::isStaticMatch, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> (Md *d, const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga52ad6fc2d41092a3afca70cc284a9a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac92ecd7e8427858137d8487c1654842b" id="r_gac92ecd7e8427858137d8487c1654842b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gac92ecd7e8427858137d8487c1654842b"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac92ecd7e8427858137d8487c1654842b">add</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gac92ecd7e8427858137d8487c1654842b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga515e562fc7fac77a4acf0c63fc2c81ec" id="r_ga515e562fc7fac77a4acf0c63fc2c81ec"><td class="memTemplParams" colspan="2"><a id="ga515e562fc7fac77a4acf0c63fc2c81ec" name="ga515e562fc7fac77a4acf0c63fc2c81ec"></a>
template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga515e562fc7fac77a4acf0c63fc2c81ec"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_matrix_dimension_match.html">detail::MatrixDimensionMatch</a>&lt; Ma, Mb &gt;::isStaticMatch, typenamedetail::_ImplMatrixAdd&lt; Ma, Mb &gt;::return_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add</b> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga515e562fc7fac77a4acf0c63fc2c81ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368c77ff8a7c63fcb562d9d6a94b4777" id="r_ga368c77ff8a7c63fcb562d9d6a94b4777"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga368c77ff8a7c63fcb562d9d6a94b4777"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga368c77ff8a7c63fcb562d9d6a94b4777">sub</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga368c77ff8a7c63fcb562d9d6a94b4777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d4e1ca405cc5ec97c9e62fae382dd0c" id="r_ga8d4e1ca405cc5ec97c9e62fae382dd0c"><td class="memTemplParams" colspan="2"><a id="ga8d4e1ca405cc5ec97c9e62fae382dd0c" name="ga8d4e1ca405cc5ec97c9e62fae382dd0c"></a>
template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga8d4e1ca405cc5ec97c9e62fae382dd0c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_matrix_dimension_match.html">detail::MatrixDimensionMatch</a>&lt; Ma, Mb &gt;::isStaticMatch, typenamedetail::_ImplMatrixAdd&lt; Ma, Mb &gt;::return_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga8d4e1ca405cc5ec97c9e62fae382dd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad75facb4800e7572c6ab6fb65d010a40" id="r_gad75facb4800e7572c6ab6fb65d010a40"><td class="memTemplParams" colspan="2">template&lt;typename U typename Matrix, typename Matrix &gt; </td></tr>
<tr class="memitem:gad75facb4800e7572c6ab6fb65d010a40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad75facb4800e7572c6ab6fb65d010a40">scale</a> (Matrix1 *d, U k, const Matrix &amp;m)</td></tr>
<tr class="separator:gad75facb4800e7572c6ab6fb65d010a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66354ae2d8a835037108e5aa813125e7" id="r_ga66354ae2d8a835037108e5aa813125e7"><td class="memTemplParams" colspan="2"><a id="ga66354ae2d8a835037108e5aa813125e7" name="ga66354ae2d8a835037108e5aa813125e7"></a>
template&lt;typename U , typename Mx , typename Md &gt; </td></tr>
<tr class="memitem:ga66354ae2d8a835037108e5aa813125e7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_is_matrix.html">detail::IsMatrix</a>&lt; Mx &gt;::valandstd::is_scalar&lt; U &gt;::valueanddetail::MatrixDimensionMatch&lt; Mx, Md &gt;::isStaticMatch, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (Md *d, U k, const Mx &amp;m)</td></tr>
<tr class="separator:ga66354ae2d8a835037108e5aa813125e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga001a4668f21e018822b92cd7ecec0cb3" id="r_ga001a4668f21e018822b92cd7ecec0cb3"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Matrix &gt; </td></tr>
<tr class="memitem:ga001a4668f21e018822b92cd7ecec0cb3"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga001a4668f21e018822b92cd7ecec0cb3">scale</a> (U k, const Matrix &amp;m)</td></tr>
<tr class="separator:ga001a4668f21e018822b92cd7ecec0cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6469b80d2c668bb389d8c7eeb8d578ee" id="r_ga6469b80d2c668bb389d8c7eeb8d578ee"><td class="memTemplParams" colspan="2"><a id="ga6469b80d2c668bb389d8c7eeb8d578ee" name="ga6469b80d2c668bb389d8c7eeb8d578ee"></a>
template&lt;typename U , typename Mx &gt; </td></tr>
<tr class="memitem:ga6469b80d2c668bb389d8c7eeb8d578ee"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_is_matrix.html">detail::IsMatrix</a>&lt; Mx &gt;::valandstd::is_scalar&lt; U &gt;::value, typenamedetail::_ImplMatrixScale&lt; Mx &gt;::return_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (U k, const Mx &amp;m)</td></tr>
<tr class="separator:ga6469b80d2c668bb389d8c7eeb8d578ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228ae7381e8456dbfb6dabe04d24d0ab" id="r_ga228ae7381e8456dbfb6dabe04d24d0ab"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Matrix &gt; </td></tr>
<tr class="memitem:ga228ae7381e8456dbfb6dabe04d24d0ab"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga228ae7381e8456dbfb6dabe04d24d0ab">operator*</a> (U k, const Matrix &amp;m)</td></tr>
<tr class="separator:ga228ae7381e8456dbfb6dabe04d24d0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5571260bd0a02e1579578fdc4c720e6e" id="r_ga5571260bd0a02e1579578fdc4c720e6e"><td class="memTemplParams" colspan="2"><a id="ga5571260bd0a02e1579578fdc4c720e6e" name="ga5571260bd0a02e1579578fdc4c720e6e"></a>
template&lt;typename U , typename Mx &gt; </td></tr>
<tr class="memitem:ga5571260bd0a02e1579578fdc4c720e6e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_is_matrix.html">detail::IsMatrix</a>&lt; Mx &gt;::valandstd::is_scalar&lt; U &gt;::value, typenamedetail::_ImplMatrixScale&lt; Mx &gt;::return_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (U k, const Mx &amp;m)</td></tr>
<tr class="separator:ga5571260bd0a02e1579578fdc4c720e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8035c8a81a1b9bdf0c25589a75d32e67" id="r_ga8035c8a81a1b9bdf0c25589a75d32e67"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Matrix &gt; </td></tr>
<tr class="memitem:ga8035c8a81a1b9bdf0c25589a75d32e67"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8035c8a81a1b9bdf0c25589a75d32e67">operator*</a> (const Matrix &amp;m, U k)</td></tr>
<tr class="separator:ga8035c8a81a1b9bdf0c25589a75d32e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d75865a71d4d835a14d4924b72e9fe" id="r_ga70d75865a71d4d835a14d4924b72e9fe"><td class="memTemplParams" colspan="2"><a id="ga70d75865a71d4d835a14d4924b72e9fe" name="ga70d75865a71d4d835a14d4924b72e9fe"></a>
template&lt;typename U , typename Mx &gt; </td></tr>
<tr class="memitem:ga70d75865a71d4d835a14d4924b72e9fe"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_is_matrix.html">detail::IsMatrix</a>&lt; Mx &gt;::valandstd::is_scalar&lt; U &gt;::value, typenamedetail::_ImplMatrixScale&lt; Mx &gt;::return_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const Mx &amp;m, U k)</td></tr>
<tr class="separator:ga70d75865a71d4d835a14d4924b72e9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade6da6e3e4d907d0d6765952654c2d43" id="r_gade6da6e3e4d907d0d6765952654c2d43"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gade6da6e3e4d907d0d6765952654c2d43"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gade6da6e3e4d907d0d6765952654c2d43">operator+</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gade6da6e3e4d907d0d6765952654c2d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f110b4450d0b986553414f50850850f" id="r_ga1f110b4450d0b986553414f50850850f"><td class="memTemplParams" colspan="2"><a id="ga1f110b4450d0b986553414f50850850f" name="ga1f110b4450d0b986553414f50850850f"></a>
template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga1f110b4450d0b986553414f50850850f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgeom_1_1detail_1_1___impl_matrix_add_return_type.html">detail::_ImplMatrixAddReturnType</a>&lt; Ma, Mb &gt;::return_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga1f110b4450d0b986553414f50850850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43544f6a7cd31e68570138205b129608" id="r_ga43544f6a7cd31e68570138205b129608"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga43544f6a7cd31e68570138205b129608"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga43544f6a7cd31e68570138205b129608">operator-</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga43544f6a7cd31e68570138205b129608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c501a03664d8b33713f8093fdca8d8e" id="r_ga2c501a03664d8b33713f8093fdca8d8e"><td class="memTemplParams" colspan="2"><a id="ga2c501a03664d8b33713f8093fdca8d8e" name="ga2c501a03664d8b33713f8093fdca8d8e"></a>
template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga2c501a03664d8b33713f8093fdca8d8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgeom_1_1detail_1_1___impl_matrix_add_return_type.html">detail::_ImplMatrixAddReturnType</a>&lt; Ma, Mb &gt;::return_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga2c501a03664d8b33713f8093fdca8d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3078b57cc5d5f7e24f5861592370d834" id="r_ga3078b57cc5d5f7e24f5861592370d834"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga3078b57cc5d5f7e24f5861592370d834"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3078b57cc5d5f7e24f5861592370d834">operator*</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga3078b57cc5d5f7e24f5861592370d834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d6d4186d5b4a132b66ef3a30af3e39" id="r_gaf7d6d4186d5b4a132b66ef3a30af3e39"><td class="memTemplParams" colspan="2"><a id="gaf7d6d4186d5b4a132b66ef3a30af3e39" name="gaf7d6d4186d5b4a132b66ef3a30af3e39"></a>
template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gaf7d6d4186d5b4a132b66ef3a30af3e39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgeom_1_1detail_1_1_matrix_mult_return_type.html">detail::MatrixMultReturnType</a>&lt; Ma, Mb &gt;::return_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gaf7d6d4186d5b4a132b66ef3a30af3e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e32cc5fa306a3025eb28a3eddd100b" id="r_gaa3e32cc5fa306a3025eb28a3eddd100b"><td class="memTemplParams" colspan="2">template&lt;typename Matix , T , M , N &gt; </td></tr>
<tr class="memitem:gaa3e32cc5fa306a3025eb28a3eddd100b"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa3e32cc5fa306a3025eb28a3eddd100b">operator*=</a> (Matrix &amp;m, const <a class="el" href="classgeom_1_1_diag_matrix.html">DiagMatrix</a>&lt; T, M, N &gt; &amp;d)</td></tr>
<tr class="separator:gaa3e32cc5fa306a3025eb28a3eddd100b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d997f3444e295b4740d1bff09e1437" id="r_ga24d997f3444e295b4740d1bff09e1437"><td class="memTemplParams" colspan="2"><a id="ga24d997f3444e295b4740d1bff09e1437" name="ga24d997f3444e295b4740d1bff09e1437"></a>
template&lt;typename Mx , typename T , index_t M, index_t N&gt; </td></tr>
<tr class="memitem:ga24d997f3444e295b4740d1bff09e1437"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_matrix_multipliable.html">detail::MatrixMultipliable</a>&lt; Mx, <a class="el" href="classgeom_1_1_diag_matrix.html">DiagMatrix</a>&lt; T, M, N &gt; &gt;::val, Mx &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Mx &amp;m, const <a class="el" href="classgeom_1_1_diag_matrix.html">DiagMatrix</a>&lt; T, M, N &gt; &amp;d)</td></tr>
<tr class="separator:ga24d997f3444e295b4740d1bff09e1437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ef83d32571cddad7b31afd449b1a3b" id="r_ga16ef83d32571cddad7b31afd449b1a3b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga16ef83d32571cddad7b31afd449b1a3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga16ef83d32571cddad7b31afd449b1a3b">operator==</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga16ef83d32571cddad7b31afd449b1a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6982263dd29b318c3f9f2198725fa5" id="r_ga6a6982263dd29b318c3f9f2198725fa5"><td class="memTemplParams" colspan="2"><a id="ga6a6982263dd29b318c3f9f2198725fa5" name="ga6a6982263dd29b318c3f9f2198725fa5"></a>
template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga6a6982263dd29b318c3f9f2198725fa5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_is_matrix.html">detail::IsMatrix</a>&lt; Ma &gt;::valanddetail::IsMatrix&lt; Mb &gt;::valanddetail::MatrixDimensionMatch&lt; Ma, Mb &gt;::isStaticMatch, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga6a6982263dd29b318c3f9f2198725fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f898de1c92712aa01388d9302bb61da" id="r_ga2f898de1c92712aa01388d9302bb61da"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga2f898de1c92712aa01388d9302bb61da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2f898de1c92712aa01388d9302bb61da">operator!=</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga2f898de1c92712aa01388d9302bb61da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ff3ba93b31aeef10a45e18ca6302cfc" id="r_ga8ff3ba93b31aeef10a45e18ca6302cfc"><td class="memTemplParams" colspan="2"><a id="ga8ff3ba93b31aeef10a45e18ca6302cfc" name="ga8ff3ba93b31aeef10a45e18ca6302cfc"></a>
template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga8ff3ba93b31aeef10a45e18ca6302cfc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_is_matrix.html">detail::IsMatrix</a>&lt; Ma &gt;::valanddetail::IsMatrix&lt; Mb &gt;::val, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga8ff3ba93b31aeef10a45e18ca6302cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58350180bfbcb6f014057e6143365394" id="r_ga58350180bfbcb6f014057e6143365394"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Matrix1 &gt; </td></tr>
<tr class="memitem:ga58350180bfbcb6f014057e6143365394"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga58350180bfbcb6f014057e6143365394">mtxcopy</a> (Matrix *into, const Matrix1 &amp;src)</td></tr>
<tr class="separator:ga58350180bfbcb6f014057e6143365394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb356233e660f730b677998b729e505e" id="r_gabb356233e660f730b677998b729e505e"><td class="memTemplParams" colspan="2"><a id="gabb356233e660f730b677998b729e505e" name="gabb356233e660f730b677998b729e505e"></a>
template&lt;typename Md , typename Ms &gt; </td></tr>
<tr class="memitem:gabb356233e660f730b677998b729e505e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mtxcopy</b> (Md *into, const Ms &amp;src, typename std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_linalg_dimension_match.html">detail::LinalgDimensionMatch</a>&lt; Md, Ms &gt;::val and(<a class="el" href="structgeom_1_1detail_1_1___impl_vec_orient.html">detail::_ImplVecOrient</a>&lt; Md, Ms &gt;::orient !=detail::ORIENT_VEC_UNKNOWN), int &gt;::type dummy=0)</td></tr>
<tr class="separator:gabb356233e660f730b677998b729e505e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99c509df6647190ac0cd0da932191bfa" id="r_ga99c509df6647190ac0cd0da932191bfa"><td class="memTemplParams" colspan="2"><a id="ga99c509df6647190ac0cd0da932191bfa" name="ga99c509df6647190ac0cd0da932191bfa"></a>
template&lt;typename Md , typename Ms &gt; </td></tr>
<tr class="memitem:ga99c509df6647190ac0cd0da932191bfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mtxcopy</b> (Md *into, const Ms &amp;src, typename std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1___impl_vec_orient.html">detail::_ImplVecOrient</a>&lt; Md, Ms &gt;::orient==detail::ORIENT_VEC_UNKNOWN, int &gt;::type dummy=0)</td></tr>
<tr class="separator:ga99c509df6647190ac0cd0da932191bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabd373e2258b3a0ad89c871606d463e1" id="r_gaabd373e2258b3a0ad89c871606d463e1"><td class="memTemplParams" colspan="2"><a id="gaabd373e2258b3a0ad89c871606d463e1" name="gaabd373e2258b3a0ad89c871606d463e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaabd373e2258b3a0ad89c871606d463e1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det2x2</b> (T a, T b, T c, T d)</td></tr>
<tr class="memdesc:gaabd373e2258b3a0ad89c871606d463e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2x2 matrix determinant from individual parameters. <br /></td></tr>
<tr class="separator:gaabd373e2258b3a0ad89c871606d463e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4061609c441ef989978b6bf3e0f422b4" id="r_ga4061609c441ef989978b6bf3e0f422b4"><td class="memTemplParams" colspan="2"><a id="ga4061609c441ef989978b6bf3e0f422b4" name="ga4061609c441ef989978b6bf3e0f422b4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4061609c441ef989978b6bf3e0f422b4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det2x2</b> (const T m[4])</td></tr>
<tr class="separator:ga4061609c441ef989978b6bf3e0f422b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb9242302749765e7f213454c8bf3b3" id="r_ga5fb9242302749765e7f213454c8bf3b3"><td class="memTemplParams" colspan="2"><a id="ga5fb9242302749765e7f213454c8bf3b3" name="ga5fb9242302749765e7f213454c8bf3b3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5fb9242302749765e7f213454c8bf3b3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det3x3</b> (const T m[9])</td></tr>
<tr class="memdesc:ga5fb9242302749765e7f213454c8bf3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3x3 matrix determinant. <br /></td></tr>
<tr class="separator:ga5fb9242302749765e7f213454c8bf3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae113643f712bbd5279077a20ac7f1a93" id="r_gae113643f712bbd5279077a20ac7f1a93"><td class="memTemplParams" colspan="2"><a id="gae113643f712bbd5279077a20ac7f1a93" name="gae113643f712bbd5279077a20ac7f1a93"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae113643f712bbd5279077a20ac7f1a93"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det3x3</b> (T a, T b, T c, T d, T e, T f, T g, T h, T i)</td></tr>
<tr class="memdesc:gae113643f712bbd5279077a20ac7f1a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3x3 matrix determinant from individual parameters. <br /></td></tr>
<tr class="separator:gae113643f712bbd5279077a20ac7f1a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b041fbf71d9db00463797883072ca92" id="r_ga6b041fbf71d9db00463797883072ca92"><td class="memTemplParams" colspan="2"><a id="ga6b041fbf71d9db00463797883072ca92" name="ga6b041fbf71d9db00463797883072ca92"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6b041fbf71d9db00463797883072ca92"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det4x4</b> (const T m[16])</td></tr>
<tr class="memdesc:ga6b041fbf71d9db00463797883072ca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 4x4 matrix determinant. <br /></td></tr>
<tr class="separator:ga6b041fbf71d9db00463797883072ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga297152d2373501d0a7bc70cf1f75af97" id="r_ga297152d2373501d0a7bc70cf1f75af97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga297152d2373501d0a7bc70cf1f75af97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga297152d2373501d0a7bc70cf1f75af97">det_destructive</a> (T *m, index_t n)</td></tr>
<tr class="memdesc:ga297152d2373501d0a7bc70cf1f75af97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructively compute the determinant of a square matrix.  <br /></td></tr>
<tr class="separator:ga297152d2373501d0a7bc70cf1f75af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c68bb91565ca449d819e0de2d3fb9e3" id="r_ga1c68bb91565ca449d819e0de2d3fb9e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c68bb91565ca449d819e0de2d3fb9e3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1c68bb91565ca449d819e0de2d3fb9e3">detNxN</a> (const T *m, index_t n)</td></tr>
<tr class="memdesc:ga1c68bb91565ca449d819e0de2d3fb9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of a square matrix.  <br /></td></tr>
<tr class="separator:ga1c68bb91565ca449d819e0de2d3fb9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1cc4a7f753961c1b26bba5e66e0c007" id="r_gad1cc4a7f753961c1b26bba5e66e0c007"><td class="memTemplParams" colspan="2">template&lt;typename T , index_t M, index_t N, MatrixLayout Lyt, <a class="el" href="group__storage.html#ga1fe6a0f4b7ba39c90d3d765ca72c3097">StoragePolicy</a> P&gt; </td></tr>
<tr class="memitem:gad1cc4a7f753961c1b26bba5e66e0c007"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad1cc4a7f753961c1b26bba5e66e0c007">det</a> (const <a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix</a>&lt; T, M, N, Lyt, P &gt; &amp;m)</td></tr>
<tr class="memdesc:gad1cc4a7f753961c1b26bba5e66e0c007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of a square matrix.  <br /></td></tr>
<tr class="separator:gad1cc4a7f753961c1b26bba5e66e0c007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e781653a5a2d1bb3a3d3e601dfa0c45" id="r_ga5e781653a5a2d1bb3a3d3e601dfa0c45"><td class="memTemplParams" colspan="2"><a id="ga5e781653a5a2d1bb3a3d3e601dfa0c45" name="ga5e781653a5a2d1bb3a3d3e601dfa0c45"></a>
template&lt;typename T , MatrixLayout Lyt, <a class="el" href="group__storage.html#ga1fe6a0f4b7ba39c90d3d765ca72c3097">StoragePolicy</a> P&gt; </td></tr>
<tr class="memitem:ga5e781653a5a2d1bb3a3d3e601dfa0c45"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix</a>&lt; T, 2, 2, Lyt, P &gt; &amp;m)</td></tr>
<tr class="separator:ga5e781653a5a2d1bb3a3d3e601dfa0c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee90152362e6335012b1de06eb7cd0e8" id="r_gaee90152362e6335012b1de06eb7cd0e8"><td class="memTemplParams" colspan="2"><a id="gaee90152362e6335012b1de06eb7cd0e8" name="gaee90152362e6335012b1de06eb7cd0e8"></a>
template&lt;typename T , MatrixLayout Lyt, <a class="el" href="group__storage.html#ga1fe6a0f4b7ba39c90d3d765ca72c3097">StoragePolicy</a> P&gt; </td></tr>
<tr class="memitem:gaee90152362e6335012b1de06eb7cd0e8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix</a>&lt; T, 3, 3, Lyt, P &gt; &amp;m)</td></tr>
<tr class="separator:gaee90152362e6335012b1de06eb7cd0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac587904abc8ef3ff4f81f5af87a1f4e8" id="r_gac587904abc8ef3ff4f81f5af87a1f4e8"><td class="memTemplParams" colspan="2"><a id="gac587904abc8ef3ff4f81f5af87a1f4e8" name="gac587904abc8ef3ff4f81f5af87a1f4e8"></a>
template&lt;typename T , MatrixLayout Lyt, <a class="el" href="group__storage.html#ga1fe6a0f4b7ba39c90d3d765ca72c3097">StoragePolicy</a> P&gt; </td></tr>
<tr class="memitem:gac587904abc8ef3ff4f81f5af87a1f4e8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix</a>&lt; T, 4, 4, Lyt, P &gt; &amp;m)</td></tr>
<tr class="separator:gac587904abc8ef3ff4f81f5af87a1f4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba01df8591b6b938c39e93120a1e04f" id="r_ga8ba01df8591b6b938c39e93120a1e04f"><td class="memTemplParams" colspan="2">template&lt;typename T , index_t N, index_t M&gt; </td></tr>
<tr class="memitem:ga8ba01df8591b6b938c39e93120a1e04f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8ba01df8591b6b938c39e93120a1e04f">det</a> (const <a class="el" href="classgeom_1_1_diag_matrix.html">DiagMatrix</a>&lt; T, N, M &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8ba01df8591b6b938c39e93120a1e04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of a diagonal matrix.  <br /></td></tr>
<tr class="separator:ga8ba01df8591b6b938c39e93120a1e04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542bc17e88d2b4615eb9ea7c909dee46" id="r_ga542bc17e88d2b4615eb9ea7c909dee46"><td class="memTemplParams" colspan="2">template&lt;index_t N&gt; </td></tr>
<tr class="memitem:ga542bc17e88d2b4615eb9ea7c909dee46"><td class="memTemplItemLeft" align="right" valign="top">index_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga542bc17e88d2b4615eb9ea7c909dee46">det</a> (const <a class="el" href="classgeom_1_1_permutation_matrix.html">PermutationMatrix</a>&lt; N &gt; &amp;m)</td></tr>
<tr class="memdesc:ga542bc17e88d2b4615eb9ea7c909dee46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of a permutation matrix.  <br /></td></tr>
<tr class="separator:ga542bc17e88d2b4615eb9ea7c909dee46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45f52ef1224908a02ac29f897d5dc2b" id="r_gad45f52ef1224908a02ac29f897d5dc2b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad45f52ef1224908a02ac29f897d5dc2b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad45f52ef1224908a02ac29f897d5dc2b">inv2x2</a> (T *out, const T m[4])</td></tr>
<tr class="memdesc:gad45f52ef1224908a02ac29f897d5dc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2  2 matrix inversion on a flat array.  <br /></td></tr>
<tr class="separator:gad45f52ef1224908a02ac29f897d5dc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0036c46ea3a84ed95e84e858939504b" id="r_gad0036c46ea3a84ed95e84e858939504b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad0036c46ea3a84ed95e84e858939504b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad0036c46ea3a84ed95e84e858939504b">inv3x3</a> (T *out, const T m[9])</td></tr>
<tr class="memdesc:gad0036c46ea3a84ed95e84e858939504b"><td class="mdescLeft">&#160;</td><td class="mdescRight">3  3 matrix inversion on a flat array.  <br /></td></tr>
<tr class="separator:gad0036c46ea3a84ed95e84e858939504b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ccb20e7982534714eb5c894f5cff8b" id="r_ga37ccb20e7982534714eb5c894f5cff8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga37ccb20e7982534714eb5c894f5cff8b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga37ccb20e7982534714eb5c894f5cff8b">inv4x4</a> (T *out, const T m[16])</td></tr>
<tr class="memdesc:ga37ccb20e7982534714eb5c894f5cff8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">4  4 matrix inversion on a flat array.  <br /></td></tr>
<tr class="separator:ga37ccb20e7982534714eb5c894f5cff8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab986054b9ddd706256dbebf46b924e22" id="r_gab986054b9ddd706256dbebf46b924e22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab986054b9ddd706256dbebf46b924e22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab986054b9ddd706256dbebf46b924e22">invNxN</a> (T *out, T *m, index_t n)</td></tr>
<tr class="memdesc:gab986054b9ddd706256dbebf46b924e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">N  N matrix inversion on a flat array.  <br /></td></tr>
<tr class="separator:gab986054b9ddd706256dbebf46b924e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a547f5eb1198f09e13b160521c7995" id="r_gaf7a547f5eb1198f09e13b160521c7995"><td class="memTemplParams" colspan="2">template&lt;typename T , index_t N&gt; </td></tr>
<tr class="memitem:gaf7a547f5eb1198f09e13b160521c7995"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf7a547f5eb1198f09e13b160521c7995">invNxN</a> (T *out, T *m)</td></tr>
<tr class="memdesc:gaf7a547f5eb1198f09e13b160521c7995"><td class="mdescLeft">&#160;</td><td class="mdescRight">N  N matrix inversion.  <br /></td></tr>
<tr class="separator:gaf7a547f5eb1198f09e13b160521c7995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Matrix-related functions and classes. </p>
<h1><a class="anchor" id="autotoc_md7"></a>
Include</h1>
<p><code>#include &lt;<a class="el" href="_matrix_8h_source.html">geomc/linalg/Matrix.h</a>&gt;</code></p>
<h1><a class="anchor" id="autotoc_md8"></a>
Design</h1>
<p>There are currently four distinct matrix template classes. They are all interoperable, and provide iterators which are functionally interchangeable with each other and with pointers (row iterators, column iterators, region iterators, and row-major matrix body iterators).</p>
<p>These iterators are compatible with std::copy(). Some of them are not writeable (or may possibly throw an error upon writing) in the case where a matrix element does not have a corresponding memory location (DiagonalMatrix is one such case, for example; off-diagonals are not stored).</p>
<p>In general, this scheme was designed to satisfy the following requirements:</p>
<ul>
<li>All matrix types must interoperate.</li>
<li>Using matrices with arithmetic operators should be straightforward, efficient, and feel like using a native type.</li>
<li><a class="el" href="structgeom_1_1_dimension.html" title="Defines a type for storing a length or element count.">Dimension</a> mismatches should be caught at compile time wherever possible, to avoid unnecessary runtime checks.</li>
<li>Element access shall be non-virtual and inline-able wherever possible.</li>
<li>Dynamic memory allocations should be minimized or eliminated wherever possible.</li>
<li>Copies to and from contiguous memory shall be fast where the internal matrix representation is contiguous.</li>
<li>Handles to matrices of arbitrary type are possible.</li>
</ul>
<h1><a class="anchor" id="autotoc_md9"></a>
Use</h1>
<h2><a class="anchor" id="autotoc_md10"></a>
Matrix dimensions</h2>
<p>Most matrices have templated size: </p><pre class="fragment">SimpleMatrix&lt;double, 3, 4&gt; mat3x4;
</pre><p>In the example above, we construct a matrix with 3 rows and 4 columns. This matrix has <b>static dimensions</b>, in that its size is chosen (and fixed) at compile-time.</p>
<p>Matrices with dimensions <b>chosen at runtime</b> may be written as: </p><pre class="fragment">SimpleMatrix&lt;double, 0, 0&gt; matNxN(nrows, ncols);
</pre><p>The primary advantage of using "static" matrices is twofold:</p>
<ul>
<li>They are backed with static arrays, and thus stack-allocated static matrices do not call <code>malloc()</code> or <code>new[]</code>, and so are faster.</li>
<li>In any given operation, the agreement of matrix dimensions can be proven at compile time, making matrix ops slightly cheaper by avoiding the check, and catching errors early. (See section on dimension checking below)</li>
</ul>
<p>Because static matrices are backed with static arrays, large static matrices should not be declared on the stack, and instead should created with the <code>new</code> operator to avoid stack overflow.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Backing storage</h2>
<p>By default, matrices generally behave as though their underlying array is duplicated whenever they are copied; ensuring two distinct matrixes do not alias the same common storage. Note that a full array copy is not always necessary (ownership transfer is optimized in c++11 with rvalue references), and careful usage can render "heavy" copies quite rare.</p>
<p>This preference to use "copy" semantics can be changed for <a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a> by passing different policies to its <code>StoragePolicy</code> template parameter.</p>
<p>To check if two matrices share any common storage: </p><pre class="fragment">if (mtx_aliases_storage(m1, m2)) { ... }
</pre><p>To copy the elements from one matrix to another, without referencing, and regardless of matrix type or static/dynamic setting: </p><pre class="fragment">mtxcopy(&amp;dst_mtx, src_mtx);
</pre><p>This method is often optimized over using std::copy() directly on the matrices' iterators. Some matrices (e.g. <a class="el" href="classgeom_1_1_diag_matrix.html" title="A matrix with nonzero elements only along the main diagonal.">DiagMatrix</a>) may not support <code>std::copy()</code>, but do support <code><a class="el" href="#ga58350180bfbcb6f014057e6143365394">mtxcopy()</a></code> with sensible arguments.</p>
<p>Unless otherwise noted, all operations on matrices should be expected to return correct results, even if the destination matrix aliases storage of an operand (though calling operations in this way may incur a performance and/or memory overhead).</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Dimension checking</h2>
<p>Matrix operations often place restrictions on the dimensions of their matrix operands. For example, matrix addition requires that both operands have the same dimensions (in other words, a 3 x 4 matrix can only be added to another 3 x 4 matrix).</p>
<p>When matrices with static dimensions are involved, the library can often prove at compile time that an argument's dimensions are correct or incorrect. If proven correct, run-time dimension checks can be skipped (by relying on compiler elimination of constructs like <code>if (false) {...}</code>), resulting in moderately faster code. If incorrect, the compiler will error, catching program correctness problems early. Compile-time dimension mismatches / requirement failures will generally manifest as <code>"template argument deduction/substitution failed"</code> errors (a more informative message would be desirable, but c++ does not provide the functionality to produce one).</p>
<p>This code will prove its dimension-correctness at compile time: </p><pre class="fragment">SimpleMatrix&lt;double, 4, 4&gt; mat4x4;
DiagMatrix&lt;double, 4, 4&gt;  dmat4x4;
SimpleMatrix&lt;double, 3, 2&gt; mat3x2;
mat4x4 + dmat4x4  // statically proven correct; no runtime dimension checking
mat4x4 + mat3x2   // COMPILE ERROR: "template argument deduction/substitution failed"
</pre><p>The last line will produce a compiler error because the matrix dimensions don't meet the operator requirements (i.e., the dimensions don't match).</p>
<p>This code will defer to a runtime check, since the dimensions of some arguments cannot be deduced from their type: </p><pre class="fragment">SimpleMatrix&lt;double, 4, 4&gt; mat4x4;
SimpleMatrix&lt;double, 0, 0&gt; mat_a_NxN(4,4); // 4x4 matrix
SimpleMatrix&lt;double, 0, 0&gt; mat_b_NxN(3,2); // 3x2 matrix

mat4x4 + mat_a_NxN; // runtime dimension check; will succeed.
mat4x4 + mat_b_NxN; // runtime dimension check; will throw an exception.
</pre><p>Runtime dimension checks will throw either a <code><a class="el" href="classgeom_1_1_dimension_mismatch_exception.html">DimensionMismatchException</a></code> or <code><a class="el" href="classgeom_1_1_nonsquare_matrix_exception.html">NonsquareMatrixException</a></code> on failure. Runtime checks can be disabled completely (at the hazard of introducing memory access violations and other bugs) by un-defining <code>GEOMC_MTX_CHECK_DIMS</code> in <code><a class="el" href="geomc__defs_8h_source.html">geomc_defs.h</a></code>. Otherwise, a runtime dimension check will occurr if any checked dimension is dynamic.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Operators</h2>
<p>Matrices support most basic arithmetic operators. We'll demonstrate with these example objects: </p><pre class="fragment">SimpleMatrix&lt;double,3,3&gt; m1;
SimpleMatrix&lt;double,3,4&gt; m2;
Vec&lt;double,3&gt; v;
</pre><p>Inter-matrix mult: </p><pre class="fragment">m1 * m2
</pre><p>Matrix-scalar mult: </p><pre class="fragment">m1 * 3
1.618 * m1
</pre><p>Matrix-vector mult: </p><pre class="fragment">m1 * v
v * m2
</pre><p>Matrix addition / subtraction: </p><pre class="fragment">m1 + m1
m1 - m1
</pre><p>Equality test: </p><pre class="fragment">m1 == m1
m1 != m2
</pre><p>Indexing: </p><pre class="fragment">double x = m1[1][2];
double y = m(2, 2);
m[0][1]  = 2.718;
m(0, 2)  = 1.618;
</pre><h2><a class="anchor" id="autotoc_md14"></a>
Accessing elements</h2>
<p>Indexing: </p><pre class="fragment">// equivalent:
float f1 = m(2, 3);
float f2 = m[2][3];
</pre><p>Assignment: </p><pre class="fragment">// all equivalent:    
m.set(2, 3, val);
m[2][3] = val;
m(2, 3) = val;
</pre><p>Matrix body iterators: </p><pre class="fragment">typedef SimpleMatrix&lt;double,3,3&gt; mat3;
mat3 m;
// iterate over the matrix body in row-major order:
for (mat3::iterator i = m.begin(); i != m.end(); i++) {
    *i = ... ;
}
</pre><p>Matrix region iterators: </p><pre class="fragment">typedef SimpleMatrix&lt;double,3,3&gt; mat3;
mat3 m;
Rect2i r = Rect2i(Vec2i(1,1), Vec2i(3,2));
// iterate over the elements in region `r` in row-major order:
for (mat3::region_iterator i = m.region_begin(r); i != m.region_end(r); i++) {
    Vec2i c = i.point();
    *i = f(c, ...);
}
</pre><h2 class="groupheader">Function Documentation</h2>
<a id="gac92ecd7e8427858137d8487c1654842b" name="gac92ecd7e8427858137d8487c1654842b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac92ecd7e8427858137d8487c1654842b">&#9670;&#160;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix add </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix addition. Add the corresponding elements of <code>a</code> and <code>b</code>, whose dimensions must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix containing <code>a + b</code>, usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>. </dd></dl>

</div>
</div>
<a id="gaa944b9a37e5ff0157724b7625d004674" name="gaa944b9a37e5ff0157724b7625d004674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa944b9a37e5ff0157724b7625d004674">&#9670;&#160;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add </td>
          <td>(</td>
          <td class="paramtype">Matrix *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix addition. Add the corresponding elements of <code>a</code> and <code>b</code>, whose dimensions must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>A writeable matrix, whose dimensions must match <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ba01df8591b6b938c39e93120a1e04f" name="ga8ba01df8591b6b938c39e93120a1e04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ba01df8591b6b938c39e93120a1e04f">&#9670;&#160;</a></span>det() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, index_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_diag_matrix.html">DiagMatrix</a>&lt; T, N, M &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the determinant of a diagonal matrix. </p>
<p>If the dimension of the matrix can be determined at compile time to be nonsquare, a static assertion is raised. Otherwise, nonsquare matrices will have determinant 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix whose determinant is to be computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga542bc17e88d2b4615eb9ea7c909dee46" name="ga542bc17e88d2b4615eb9ea7c909dee46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga542bc17e88d2b4615eb9ea7c909dee46">&#9670;&#160;</a></span>det() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;index_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">index_t det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_permutation_matrix.html">PermutationMatrix</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the determinant of a permutation matrix. </p>
<p>If the dimension of the matrix is dynamic and larger than 32, heap memory may be allocated as buffer space for the computation.</p>
<p>If it is desired that no heap memory be allocated, consider using <code><a class="el" href="namespacegeom.html#a24a3caa81b25a5962aa1266e1d63773b" title="Compute the sign of a permutation, resetting the permutation to identity in the process.">permutation_sign()</a></code>, which is equal to the permutation's determinant, and uses the permutation map (destructively) as a buffer for the calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The permutation matrix whose determinant is to be computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1cc4a7f753961c1b26bba5e66e0c007" name="gad1cc4a7f753961c1b26bba5e66e0c007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1cc4a7f753961c1b26bba5e66e0c007">&#9670;&#160;</a></span>det() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t M, index_t N, MatrixLayout Lyt, <a class="el" href="group__storage.html#ga1fe6a0f4b7ba39c90d3d765ca72c3097">StoragePolicy</a> P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix</a>&lt; T, M, N, Lyt, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the determinant of a square matrix. </p>
<p>If the dimension of the matrix is larger than 8, heap memory may be allocated as buffer space for the computation.</p>
<p>If the dimension of the matrix can be determined at compile time to be nonsquare, a static assertion is raised. Otherwise, nonsquare matrices will have determinant 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The square matrix whose determinant is to be computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga297152d2373501d0a7bc70cf1f75af97" name="ga297152d2373501d0a7bc70cf1f75af97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga297152d2373501d0a7bc70cf1f75af97">&#9670;&#160;</a></span>det_destructive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T det_destructive </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructively compute the determinant of a square matrix. </p>
<p>The provided matrix will be used as a buffer for the computation, and no additional memory will be allocated. The contents of <code>m</code> after the function returns are undefined.</p>
<p>Note that it is generally preferable to use one of the <code>detNxN</code> methods if the dimension is small and known at compile time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The square matrix whose determinant is to be computed. <code>m</code> may be either row- or column- major layout. The contents of <code>m</code> will be overwritten. </td></tr>
    <tr><td class="paramname">n</td><td>The number of rows/columns in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c68bb91565ca449d819e0de2d3fb9e3" name="ga1c68bb91565ca449d819e0de2d3fb9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c68bb91565ca449d819e0de2d3fb9e3">&#9670;&#160;</a></span>detNxN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T detNxN </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the determinant of a square matrix. </p>
<p>If <code>n</code> is larger than 8, heap memory may be allocated as buffer space for the computation. (To avoid heap allocation, use <code><a class="el" href="#ga297152d2373501d0a7bc70cf1f75af97" title="Destructively compute the determinant of a square matrix.">det_destructive()</a></code> instead).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The square matrix whose determinant is to be computed. <code>m</code> may be either row- or column- major layout. </td></tr>
    <tr><td class="paramname">n</td><td>The number of rows/columns in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac0cb024cab6ab5d63b8a246e557e5b5" name="gaac0cb024cab6ab5d63b8a246e557e5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac0cb024cab6ab5d63b8a246e557e5b5">&#9670;&#160;</a></span>inv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix inv </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>success</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix inversion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A square matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">success</td><td>Will be set to <code>false</code> if the matrix was singular and could not be inverted, otherwise will be set to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix containing the inverse of <code>m</code>, or undefined data if <code>m</code> could not be inverted. </dd></dl>

</div>
</div>
<a id="ga295757f10d10ded031d121542c91537e" name="ga295757f10d10ded031d121542c91537e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga295757f10d10ded031d121542c91537e">&#9670;&#160;</a></span>inv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inv </td>
          <td>(</td>
          <td class="paramtype">Matrix1 *</td>          <td class="paramname"><span class="paramname"><em>into</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix inversion. <code>src</code> and <code>into</code> must be square matrices of the same dimension. If a runtime check for square dimensions fails, a <code><a class="el" href="classgeom_1_1_nonsquare_matrix_exception.html">NonsquareMatrixException</a></code> is raised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix with dimensions equal to <code>src</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A square matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the matrix is singular and could not be inverted, <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad45f52ef1224908a02ac29f897d5dc2b" name="gad45f52ef1224908a02ac29f897d5dc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad45f52ef1224908a02ac29f897d5dc2b">&#9670;&#160;</a></span>inv2x2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inv2x2 </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>m</em></span>[4]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2  2 matrix inversion on a flat array. </p>
<p><code>out</code> and <code>m</code> may alias each other. It is assumed that <code>m</code> and <code>out</code> have the same layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An array with space for four elements to receive the computed inverse. </td></tr>
    <tr><td class="paramname">m</td><td>The 2  2 matrix to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is invertible, false otherwise. If the matrix is not invertible, then <code>out</code> is unchanged. </dd></dl>

</div>
</div>
<a id="gad0036c46ea3a84ed95e84e858939504b" name="gad0036c46ea3a84ed95e84e858939504b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0036c46ea3a84ed95e84e858939504b">&#9670;&#160;</a></span>inv3x3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inv3x3 </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>m</em></span>[9]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3  3 matrix inversion on a flat array. </p>
<p><code>out</code> and <code>m</code> may alias each other. It is assumed that <code>m</code> and <code>out</code> have the same layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An array with space for nine elements to receive the computed inverse. </td></tr>
    <tr><td class="paramname">m</td><td>The 3  3 matrix to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is invertible, false otherwise. If the matrix is not invertible, then <code>out</code> is unchanged. </dd></dl>

</div>
</div>
<a id="ga37ccb20e7982534714eb5c894f5cff8b" name="ga37ccb20e7982534714eb5c894f5cff8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37ccb20e7982534714eb5c894f5cff8b">&#9670;&#160;</a></span>inv4x4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inv4x4 </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>m</em></span>[16]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>4  4 matrix inversion on a flat array. </p>
<p><code>out</code> and <code>m</code> may alias each other. It is assumed that <code>m</code> and <code>out</code> have the same layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An array with space for 16 elements to receive the computed inverse. </td></tr>
    <tr><td class="paramname">m</td><td>The 4  4 matrix to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is invertible, false otherwise. If the matrix is not invertible, then <code>out</code> is unchanged. </dd></dl>

</div>
</div>
<a id="gaf7a547f5eb1198f09e13b160521c7995" name="gaf7a547f5eb1198f09e13b160521c7995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a547f5eb1198f09e13b160521c7995">&#9670;&#160;</a></span>invNxN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool invNxN </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>N  N matrix inversion. </p>
<p>After the inversion, <code>m</code> will have undefined contents, regardless of whether it was invertible.</p>
<p>It is assumed that <code>m</code> and <code>out</code> have the same layout. <code>m</code> <em>must not</em> alias <code>out</code>.</p>
<p>This function uses a general inversion algorithm, and the specialized dimension-specific algorithms will be preferable when the dimension is known.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The dimension <code>N</code> of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An array with space for <code>N</code><sup>2</sup> elements to receive the computed inverse. </td></tr>
    <tr><td class="paramname">m</td><td>The N  N matrix to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is invertible, false otherwise. If the matrix is not invertible, then <code>out</code> is unchanged. </dd></dl>

</div>
</div>
<a id="gab986054b9ddd706256dbebf46b924e22" name="gab986054b9ddd706256dbebf46b924e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab986054b9ddd706256dbebf46b924e22">&#9670;&#160;</a></span>invNxN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool invNxN </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>N  N matrix inversion on a flat array. </p>
<p>After the inversion, <code>m</code> will have undefined contents, regardless of whether it was invertible.</p>
<p>It is assumed that <code>m</code> and <code>out</code> have the same layout. <code>m</code> <em>must not</em> alias <code>out</code>.</p>
<p>This function uses a general inversion algorithm, and the specialized dimension-specific algorithms will be preferable when the dimension is known.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An array with space for <code>N</code><sup>2</sup> elements to receive the computed inverse. </td></tr>
    <tr><td class="paramname">m</td><td>The N  N matrix to invert. </td></tr>
    <tr><td class="paramname">n</td><td>The dimension <code>N</code> of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is invertible, false otherwise. If the matrix is not invertible, then <code>out</code> is unchanged. </dd></dl>

</div>
</div>
<a id="gaddebe98a06082a435254a640ba53e28c" name="gaddebe98a06082a435254a640ba53e28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddebe98a06082a435254a640ba53e28c">&#9670;&#160;</a></span>mtx_aliases_storage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ma , typename Mb &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtx_aliases_storage </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do two matrices / vectors share storage?</p>
<p>In other words, might writing to one object change the contents of the other? <code>Matrix1</code> and <code>Matrix2</code> must be matrix or vector types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix or vector object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix or vector object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if writing to <code>a</code> may alter <code>b</code> or vice versa; <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga58350180bfbcb6f014057e6143365394" name="ga58350180bfbcb6f014057e6143365394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58350180bfbcb6f014057e6143365394">&#9670;&#160;</a></span>mtxcopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Matrix1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mtxcopy </td>
          <td>(</td>
          <td class="paramtype">Matrix *</td>          <td class="paramname"><span class="paramname"><em>into</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the contents of <code>src</code> into <code>into</code>. This function may be optimized to perform better than running <code>std::copy()</code> on some matrix types' iterators. It will also succeed in certain situations where <code>std::copy()</code> would fail (for example when copying the contents of a diagonal matrix to another, any attempt to write off the diagonal will cause an error).</p>
<p><code>Matrix</code> and <code>Matrix1</code> must be matrix or vector types whose dimensions match. If the dimensions can be determined to mismatch at compile-time, the program is considered invalid and the compilation will fail. If either object has dynamic size, the check will be deferred to runtime, throwing a <code><a class="el" href="classgeom_1_1_dimension_mismatch_exception.html">DimensionMismatchException</a></code> if the check fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix with dimensions matching <code>src</code>'s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A matrix object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37c0fecbc60b92f4e8a2141520a43ed8" name="ga37c0fecbc60b92f4e8a2141520a43ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37c0fecbc60b92f4e8a2141520a43ed8">&#9670;&#160;</a></span>mul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix mul </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix multiplication.</p>
<p><code>Matrix1</code> and <code>Matrix2</code> may either be matrices or vectors. Left operands are, if vectors, assumed to be rows, while right operands will be treated as columns. The dimensions of <code>a</code> and <code>b</code> must satisfy <code>(a x b) * (b x c)</code>. If the dimensions can be determined to mismatch at compile time, the program is considered invalid and will not compile. If either argument has dynamic size, the dimension check will be performed at runtime, raising a <code><a class="el" href="classgeom_1_1_dimension_mismatch_exception.html">DimensionMismatchException</a></code> if it fails.</p>
<p>The return type will be chosen appropriately based on the arguments, and will have dimension <code>(a x c)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object or vector with dimension <code>(N x b.rows())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object or vector with dimension <code>(a.cols() x N)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix or vector object containing the result of <code>a * b</code>. </dd></dl>

</div>
</div>
<a id="gaf4cc58853d04688d1bf2dc0ed7feb78b" name="gaf4cc58853d04688d1bf2dc0ed7feb78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4cc58853d04688d1bf2dc0ed7feb78b">&#9670;&#160;</a></span>mul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; mul </td>
          <td>(</td>
          <td class="paramtype">Matrix *</td>          <td class="paramname"><span class="paramname"><em>into</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix * matrix and matrix * vector multiplication</p>
<p>This function handles all multiplication between any two types of matrix, or between any matrix and a vector. Thus, <code>Ma</code>, <code>Mb</code>, (the operands) and <code>Md</code> (the destination), may each be either a matrix or a vector. If the left operand is a vector, it is assumed to be a row vector, whereas right vector operands are column vectors.</p>
<p>This function ensures that all compile-time checkable dimensions agree&ndash; that is to say, that <code>(a x b) * (b x c) = (a x c)</code> holds. If any object has a dynamic size, then the check will be deferred to runtime, and a <a class="el" href="classgeom_1_1_dimension_mismatch_exception.html">DimensionMismatchException</a> thrown if the check fails. A compile-time dimension mismatch implies the program is invalid and compilation will error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix or vector with dimensions <code>(a.rows() x b.cols())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object or vector with dimension <code>(N x b.rows())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object or vector with dimension <code>(a.cols() x N)</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0484c4fd6e6582fcdba6354a608ff317" name="ga0484c4fd6e6582fcdba6354a608ff317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0484c4fd6e6582fcdba6354a608ff317">&#9670;&#160;</a></span>mul_acc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Md , typename Ma , typename Mb &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structgeom_1_1detail_1_1_matrix_multipliable.html">detail::MatrixMultipliable</a>&lt; Ma, Mb &gt;::valanddetail::_ImplMtxResult&lt; Ma, Mb, Md &gt;::agreement==detail::MTX_RESULT_MATCH, Md &amp; &gt;::type mul_acc </td>
          <td>(</td>
          <td class="paramtype">Md *</td>          <td class="paramname"><span class="paramname"><em>into</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ma &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Accumulate the result of a matrix multiplication into a destination matrix. (a x b) * (b x c) += (a x c) </p>

</div>
</div>
<a id="ga2f898de1c92712aa01388d9302bb61da" name="ga2f898de1c92712aa01388d9302bb61da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f898de1c92712aa01388d9302bb61da">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix != matrix.</p>
<p>Matrices <code>a</code> and <code>b</code> are unequal unless <code>a</code> and <code>b</code> have the same dimension and all corresponding elements are equal. </p>

</div>
</div>
<a id="ga8035c8a81a1b9bdf0c25589a75d32e67" name="ga8035c8a81a1b9bdf0c25589a75d32e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8035c8a81a1b9bdf0c25589a75d32e67">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix operator* </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix * scalar</p>
<p>All elements of <code>m</code> are multiplied by <code>k</code>. <code>Matrix</code> must be a matrix type, and <code>U</code> must satisfy <code>std::is_scalar&lt;U&gt;</code>. </p>

</div>
</div>
<a id="ga3078b57cc5d5f7e24f5861592370d834" name="ga3078b57cc5d5f7e24f5861592370d834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3078b57cc5d5f7e24f5861592370d834">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix operator* </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix * matrix</p>
<p>Matrix multiplication is performed on <code>a</code> and <code>b</code>.</p>
<p><code>Matrix1</code> and <code>Matrix2</code> may either be matrices or vectors (but may not <em>both</em> be vectors; this is handled by a different multiplication operator). Left operands are, if vectors, assumed to be rows, while right operands will be treated as columns. The dimensions of <code>a</code> and <code>b</code> must satisfy <code>(a x b) * (b x c)</code>. If the dimensions can be determined to mismatch at compile time, the program is considered invalid and will not compile. If either argument has dynamic size, the dimension check will be performed at runtime, raising a <code><a class="el" href="classgeom_1_1_dimension_mismatch_exception.html">DimensionMismatchException</a></code> if it fails.</p>
<p>The return type will be chosen appropriately based on the arguments, and will have dimension <code>(a x c)</code>. </p>

</div>
</div>
<a id="ga228ae7381e8456dbfb6dabe04d24d0ab" name="ga228ae7381e8456dbfb6dabe04d24d0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga228ae7381e8456dbfb6dabe04d24d0ab">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix operator* </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>scalar * matrix</p>
<p>All elements of <code>m</code> are multiplied by <code>k</code>. <code>Matrix</code> must be a matrix type, and <code>U</code> must satisfy <code>std::is_scalar&lt;U&gt;</code>. </p>

</div>
</div>
<a id="gaa3e32cc5fa306a3025eb28a3eddd100b" name="gaa3e32cc5fa306a3025eb28a3eddd100b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3e32cc5fa306a3025eb28a3eddd100b">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matix , T , M , N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_diag_matrix.html">DiagMatrix</a>&lt; T, M, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix *= diagonal matrix</p>
<p>A matrix <code>m</code> is multiplied by diagonal matrix <code>d</code>.</p>
<p>In this case, multiplication is efficient and memory allocation is avoided, even in the case where <code>m</code> and <code>d</code> alias. </p>

</div>
</div>
<a id="gade6da6e3e4d907d0d6765952654c2d43" name="gade6da6e3e4d907d0d6765952654c2d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade6da6e3e4d907d0d6765952654c2d43">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix operator+ </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix + matrix</p>
<p>Add the elements of <code>a</code> and <code>b</code>. The return type will be chosen appropriately based on the arguments (usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>). <code>Matrix1</code> and <code>Matrix2</code> must both be matrix types. </p>

</div>
</div>
<a id="ga43544f6a7cd31e68570138205b129608" name="ga43544f6a7cd31e68570138205b129608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43544f6a7cd31e68570138205b129608">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix operator- </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix - matrix.</p>
<p>Subtract the elements of <code>b</code> from <code>a</code>. The return type will be chosen appropriately based on the arguments (usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>). <code>Matrix1</code> and <code>Matrix2</code> must both be matrix types. </p>

</div>
</div>
<a id="ga16ef83d32571cddad7b31afd449b1a3b" name="ga16ef83d32571cddad7b31afd449b1a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16ef83d32571cddad7b31afd449b1a3b">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix == matrix.</p>
<p>Matrices <code>a</code> and <code>b</code> are equal if and only if <code>a</code> and <code>b</code> have the same dimension and all corresponding elements are equal. <code>Matrix1</code> and <code>Matrix2</code> must both be matrix types. </p>

</div>
</div>
<a id="gad75facb4800e7572c6ab6fb65d010a40" name="gad75facb4800e7572c6ab6fb65d010a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad75facb4800e7572c6ab6fb65d010a40">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U typename Matrix, typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scale </td>
          <td>(</td>
          <td class="paramtype">Matrix1 *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar muliplication on matrices. In other words, multiply all the elements of <code>m</code> by scalar value <code>k</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>A writeable matrix, whose dimensions must match those of <code>m</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Scalar constant (whose type satisfies <code>std::is_scalar&lt;U&gt;</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix object to be scaled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga001a4668f21e018822b92cd7ecec0cb3" name="ga001a4668f21e018822b92cd7ecec0cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga001a4668f21e018822b92cd7ecec0cb3">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix scale </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar muliplication on matrices. In other words, multiply all the elements of <code>m</code> by scalar value <code>k</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Scalar constant (whose type satisfies <code>std::is_scalar&lt;U&gt;</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix object to be scaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scaled copy of <code>m</code>. </dd></dl>

</div>
</div>
<a id="ga368c77ff8a7c63fcb562d9d6a94b4777" name="ga368c77ff8a7c63fcb562d9d6a94b4777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga368c77ff8a7c63fcb562d9d6a94b4777">&#9670;&#160;</a></span>sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix sub </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix subtraction. Subtract the corresponding elements of <code>b</code> from <code>a</code>'s. The dimensions of <code>a</code> and <code>b</code> must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Matrix object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix containing <code>a - b</code>, usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>. </dd></dl>

</div>
</div>
<a id="gad0bdc9a1392c82fa16cda590742b442a" name="gad0bdc9a1392c82fa16cda590742b442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0bdc9a1392c82fa16cda590742b442a">&#9670;&#160;</a></span>sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sub </td>
          <td>(</td>
          <td class="paramtype">Matrix *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix subtraction. Subtract the corresponding elements of <code>b</code> from <code>a</code>'s. The dimensions of <code>a</code> and <code>b</code> must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>A writeable matrix, whose dimensions must match <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22531038b8c151d265d975efb298799c" name="ga22531038b8c151d265d975efb298799c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22531038b8c151d265d975efb298799c">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix transpose </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix transpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A matrix object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A transposed copy of <code>m</code>, of type appropriate for the argument, usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>. </dd></dl>

</div>
</div>
<a id="ga8607b52b5602a3a36d694b83684e8b01" name="ga8607b52b5602a3a36d694b83684e8b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8607b52b5602a3a36d694b83684e8b01">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void transpose </td>
          <td>(</td>
          <td class="paramtype">Matrix1 *</td>          <td class="paramname"><span class="paramname"><em>into</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix transpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix with dimensions <code>(m.cols(), m.rows())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 18 2025 21:36:32 for geomc by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
