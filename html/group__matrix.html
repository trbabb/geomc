<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geomc: Matrix</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">geomc
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A c++ linear algebra template library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Matrix<div class="ingroups"><a class="el" href="group__linalg.html">Linalg</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix-related functions and classes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_p_l_u_decomposition.html">PLUDecomposition&lt; T, M, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU decompostion for a matrix <code>A</code>, such that <code>PA = LU</code>.  <a href="classgeom_1_1_p_l_u_decomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_augmented_matrix.html">AugmentedMatrix&lt; Ma, Mb &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix which wraps two side-by-side sub-matrices.  <a href="classgeom_1_1_augmented_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_diag_matrix.html">DiagMatrix&lt; T, M, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with nonzero elements only along the main diagonal.  <a href="classgeom_1_1_diag_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_matrix_handle.html">MatrixHandle&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic matrix class which can hold references to all other matrix types.  <a href="classgeom_1_1_matrix_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_permutation_matrix.html">PermutationMatrix&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix which, by multiplication, permutes the rows or columns of another matrix.  <a href="classgeom_1_1_permutation_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix&lt; T, M, N, P &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic matrix with <code>M x N</code> elements.  <a href="classgeom_1_1_simple_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaece56584613790b7e364cf00b93ee36a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gaece56584613790b7e364cf00b93ee36a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaece56584613790b7e364cf00b93ee36a">mtx_aliases_storage</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gaece56584613790b7e364cf00b93ee36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f7b11d56dfce541930313e00471845a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga3f7b11d56dfce541930313e00471845a"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga3f7b11d56dfce541930313e00471845a">mul</a> (Matrix *into, const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga3f7b11d56dfce541930313e00471845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d61c9c78d6cfeec7f676ebbf028970c"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga2d61c9c78d6cfeec7f676ebbf028970c"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga2d61c9c78d6cfeec7f676ebbf028970c">mul</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga2d61c9c78d6cfeec7f676ebbf028970c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2d064d06760e230385ca5fcc0a29fd"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gafd2d064d06760e230385ca5fcc0a29fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gafd2d064d06760e230385ca5fcc0a29fd">transpose</a> (Matrix1 *into, const Matrix2 &amp;m)</td></tr>
<tr class="separator:gafd2d064d06760e230385ca5fcc0a29fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabd880a0d5fc18a0657bdff67c20c495"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 &gt; </td></tr>
<tr class="memitem:gaabd880a0d5fc18a0657bdff67c20c495"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaabd880a0d5fc18a0657bdff67c20c495">transpose</a> (const Matrix1 &amp;m)</td></tr>
<tr class="separator:gaabd880a0d5fc18a0657bdff67c20c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7a0b519bdbfd166ab4d93bece17f2e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gaae7a0b519bdbfd166ab4d93bece17f2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaae7a0b519bdbfd166ab4d93bece17f2e">inv</a> (Matrix1 *into, const Matrix2 &amp;src)</td></tr>
<tr class="separator:gaae7a0b519bdbfd166ab4d93bece17f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcedf9e35d1bb65a05f08a0d657bbbfb"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 &gt; </td></tr>
<tr class="memitem:gabcedf9e35d1bb65a05f08a0d657bbbfb"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gabcedf9e35d1bb65a05f08a0d657bbbfb">inv</a> (const Matrix1 &amp;m, bool *success)</td></tr>
<tr class="separator:gabcedf9e35d1bb65a05f08a0d657bbbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29282e95cba76934ebf5ebff8dabf1d"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gad29282e95cba76934ebf5ebff8dabf1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gad29282e95cba76934ebf5ebff8dabf1d">add</a> (Matrix *d, const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gad29282e95cba76934ebf5ebff8dabf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd89060fc778b8fdccc689754607925"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gaedd89060fc778b8fdccc689754607925"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaedd89060fc778b8fdccc689754607925">sub</a> (Matrix *d, const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gaedd89060fc778b8fdccc689754607925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd7d99bad76113a8697036b8fe9a5ad"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gaebd7d99bad76113a8697036b8fe9a5ad"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaebd7d99bad76113a8697036b8fe9a5ad">add</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gaebd7d99bad76113a8697036b8fe9a5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37c042365e8f243c7b7fa077e690995"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gab37c042365e8f243c7b7fa077e690995"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gab37c042365e8f243c7b7fa077e690995">sub</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gab37c042365e8f243c7b7fa077e690995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef5d783aa86e83c9666737f6b496cd3"><td class="memTemplParams" colspan="2">template&lt;typename U typename Matrix, typename Matrix &gt; </td></tr>
<tr class="memitem:gaaef5d783aa86e83c9666737f6b496cd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaaef5d783aa86e83c9666737f6b496cd3">scale</a> (Matrix1 *d, U k, const Matrix &amp;m)</td></tr>
<tr class="separator:gaaef5d783aa86e83c9666737f6b496cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432043158b759a37a48d1c1855f863c3"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Matrix &gt; </td></tr>
<tr class="memitem:ga432043158b759a37a48d1c1855f863c3"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga432043158b759a37a48d1c1855f863c3">scale</a> (U k, const Matrix &amp;m)</td></tr>
<tr class="separator:ga432043158b759a37a48d1c1855f863c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99c139a4368bc2abeea5b2d39a0fbb5c"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Matrix &gt; </td></tr>
<tr class="memitem:ga99c139a4368bc2abeea5b2d39a0fbb5c"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga99c139a4368bc2abeea5b2d39a0fbb5c">operator*</a> (U k, const Matrix &amp;m)</td></tr>
<tr class="separator:ga99c139a4368bc2abeea5b2d39a0fbb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba31a5d092076a91ccdadf0072e80fdb"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Matrix &gt; </td></tr>
<tr class="memitem:gaba31a5d092076a91ccdadf0072e80fdb"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaba31a5d092076a91ccdadf0072e80fdb">operator*</a> (const Matrix &amp;m, U k)</td></tr>
<tr class="separator:gaba31a5d092076a91ccdadf0072e80fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a2a9df9697a40eeb4bdf795f35b3c6"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gaa1a2a9df9697a40eeb4bdf795f35b3c6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaa1a2a9df9697a40eeb4bdf795f35b3c6">operator+</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gaa1a2a9df9697a40eeb4bdf795f35b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204dfbeacaf70f1712bde20a2b3806b3"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga204dfbeacaf70f1712bde20a2b3806b3"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga204dfbeacaf70f1712bde20a2b3806b3">operator-</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga204dfbeacaf70f1712bde20a2b3806b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb844d5ef54addfd4be39a3cc171940a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gadb844d5ef54addfd4be39a3cc171940a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gadb844d5ef54addfd4be39a3cc171940a">operator*</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gadb844d5ef54addfd4be39a3cc171940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc066c784d93944802791afbb4d8bde"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ga9bc066c784d93944802791afbb4d8bde"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga9bc066c784d93944802791afbb4d8bde">operator==</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:ga9bc066c784d93944802791afbb4d8bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf95ce414e21e18e3da3f526b52dad7"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:gaedf95ce414e21e18e3da3f526b52dad7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaedf95ce414e21e18e3da3f526b52dad7">operator!=</a> (const Matrix1 &amp;a, const Matrix2 &amp;b)</td></tr>
<tr class="separator:gaedf95ce414e21e18e3da3f526b52dad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18aa4cc96039ea7bf54d7d9fb25defe4"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Matrix1 &gt; </td></tr>
<tr class="memitem:ga18aa4cc96039ea7bf54d7d9fb25defe4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga18aa4cc96039ea7bf54d7d9fb25defe4">mtxcopy</a> (Matrix *into, const Matrix1 &amp;src)</td></tr>
<tr class="separator:ga18aa4cc96039ea7bf54d7d9fb25defe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Matrix-related functions and classes. </p>
<h1>Include </h1>
<p><code>#include &lt;<a class="el" href="_matrix_8h_source.html">geomc/linalg/Matrix.h</a>&gt;</code></p>
<h1>Design </h1>
<p>There are currently six distinct matrix template classes. They are all interoperable, and provide iterators which are functionally interchangeable with each other and with pointers (row iterators, column iterators, region iterators, and row-major matrix body iterators).</p>
<p>These iterators are compatible with std::copy(). Some of them are not writeable (or may possibly throw an error upon writing) in the case where a matrix element does not have a corresponding memory location (DiagonalMatrix is one such case, for example; off-diagonals are not stored).</p>
<p>In general, this scheme was designed to satisfy the following requirements:</p>
<ul>
<li>All matrix types must interoperate.</li>
<li>Using matrices with arithmetic operators should be straightforward, efficient, and feel like using a native type.</li>
<li><a class="el" href="structgeom_1_1_dimension.html" title="Defines a type for storing a length or element count. ">Dimension</a> mismatches should be caught at compile time wherever possible, to avoid unnecessary runtime checks.</li>
<li>Element access shall be non-virtual and inline-able wherever possible.</li>
<li>Dynamic memory allocations should be minimized or eliminated wherever possible.</li>
<li>Copies to and from contiguous memory shall be fast where the internal matrix representation is contiguous.</li>
<li>Handles to matrices of arbitrary type are possible.</li>
</ul>
<h1>Use </h1>
<h2>Matrix dimensions </h2>
<p>Most matrices have templated size: </p><pre class="fragment">SimpleMatrix&lt;double, 3, 4&gt; mat3x4;
</pre><p>In the example above, we construct a matrix with 3 rows and 4 columns. This matrix has <b>static dimensions</b>, in that its size is chosen (and fixed) at compile-time.</p>
<p>Matrices with dimensions <b>chosen at runtime</b> may be written as: </p><pre class="fragment">SimpleMatrix&lt;double, 0, 0&gt; matNxN(nrows, ncols);
</pre><p>The primary advantage of using "static" matrices is twofold:</p>
<ul>
<li>They are backed with static arrays, and thus stack-allocated static matrices do not call <code>malloc()</code> or <code>new[]</code>, and so are faster.</li>
<li>In any given operation, the agreement of matrix dimensions can be proven at compile time, making matrix ops slightly cheaper by avoiding the check, and catching errors early. (See section on dimension checking below)</li>
</ul>
<p>Because static matrices are backed with static arrays, large static matrices should not be declared on the stack, and instead should created with the <code>new</code> operator to avoid stack overflow.</p>
<h2>Backing storage </h2>
<p>By default, matrices generally behave as though their underlying array is duplicated whenever they are copied; ensuring two distinct matrixes do not alias the same common storage. Note that a full array copy is not always necessary (ownership transfer is optimized in c++11 with rvalue references), and careful usage can render "heavy" copies quite rare.</p>
<p>This preference to use "copy" semantics can be changed for <a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements. ">SimpleMatrix</a> by passing different policies to its <code>StoragePolicy</code> template parameter.</p>
<p>To check if two matrices share any common storage: </p><pre class="fragment">if (mtx_aliases_storage(m1, m2)) { ... }
</pre><p>To copy the elements from one matrix to another, without referencing, and regardless of matrix type or static/dynamic setting: </p><pre class="fragment">mtxcopy(&amp;dst_mtx, src_mtx);
</pre><p>This method is often optimized over using std::copy() directly on the matrices' iterators. Some matrices (e.g. <a class="el" href="classgeom_1_1_diag_matrix.html" title="A matrix with nonzero elements only along the main diagonal. ">DiagMatrix</a>) may not support <code>std::copy()</code>, but do support <code><a class="el" href="group__matrix.html#ga18aa4cc96039ea7bf54d7d9fb25defe4">mtxcopy()</a></code> with sensible arguments.</p>
<p>Unless otherwise noted, all operations on matrices are guaranteed to return correct results, even if the destination matrix aliases storage of an operand (though calling operations in this way may incur a performance and/or memory overhead).</p>
<h2><a class="el" href="structgeom_1_1_dimension.html" title="Defines a type for storing a length or element count. ">Dimension</a> checking </h2>
<p>Matrix operations often place restrictions on the dimensions of their matrix operands. For example, matrix addition requires that both operands have the same dimensions (in other words, a 3 x 4 matrix can only be added to another 3 x 4 matrix).</p>
<p>When matrices with static dimensions are involved, the library can often prove at compile time that an argument's dimensions are correct or incorrect. If proven correct, run-time dimension checks can be skipped (by relying on compiler elimination of constructs like <code>if (0) {...}</code>), resulting in slightly faster code. If incorrect, the compiler will error, catching program correctness problems early. Compile-time dimension mismatches / requirement failures will generally manifest as <code>"template argument deduction/substitution failed"</code> errors (a more informative message would be desirable, but c++ does not provide the functionality to produce one).</p>
<p>This code will prove its dimension-correctness at compile time: </p><pre class="fragment">SimpleMatrix&lt;double, 4, 4&gt; mat4x4;
DiagMatrix&lt;double, 4, 4&gt;  dmat4x4;
SimpleMatrix&lt;double, 3, 2&gt; mat3x2;
mat4x4 + dmat4x4  // statically proven correct; no runtime dimension checking
mat4x4 + mat3x2   // COMPILE ERROR: "template argument deduction/substitution failed"
</pre><p>The last line will produce a compiler error because the matrix dimensions don't meet the operator requirements (i.e., the dimensions don't match).</p>
<p>This code will defer to a runtime check, since the dimensions of some arguments cannot be deduced from their type: </p><pre class="fragment">SimpleMatrix&lt;double, 4, 4&gt; mat4x4;
SimpleMatrix&lt;double, 0, 0&gt; mat_a_NxN(4,4); // 4x4 matrix
SimpleMatrix&lt;double, 0, 0&gt; mat_b_NxN(3,2); // 3x2 matrix

mat4x4 + mat_a_NxN; // runtime dimension check; will succeed.
mat4x4 + mat_b_NxN; // runtime dimension check; will throw an exception.
</pre><p>Runtime dimension checks will throw either a <code>DimensionMismatchException</code> or <code>NonsquareMatrixException</code> on failure. Runtime checks can be disabled completely (at the hazard of introducing memory access violations and other bugs) by un-defining <code>GEOMC_MTX_CHECK_DIMS</code> in <code><a class="el" href="geomc__defs_8h_source.html">geomc_defs.h</a></code>. Otherwise, a runtime dimension check will occurr if any checked dimension is dynamic.</p>
<h2>Operators </h2>
<p>Matrices support most basic arithmetic operators. We'll demonstrate with these example objects: </p><pre class="fragment">SimpleMatrix&lt;double,3,3&gt; m1;
SimpleMatrix&lt;double,3,4&gt; m2;
Vec&lt;double,3&gt; v;
</pre><p>Inter-matrix mult: </p><pre class="fragment">m1 * m2
</pre><p>Matrix-scalar mult: </p><pre class="fragment">m1 * 3
1.618 * m1
</pre><p>Matrix-vector mult: </p><pre class="fragment">m1 * v
v * m2
</pre><p>Matrix addition / subtraction: </p><pre class="fragment">m1 + m1
m1 - m1
</pre><p>Equality test: </p><pre class="fragment">m1 == m1
m1 != m2
</pre><p>Indexing: </p><pre class="fragment">double x = m1[1][2];
m[0][1] = 2.718;
</pre><h2>Accessing elements </h2>
<p>Indexing: </p><pre class="fragment">// equivalent:
float f1 = m.get(2, 3);
float f2 = m[2][3]; 
</pre><p>Assignment: </p><pre class="fragment">// all equivalent:    
m.set(2, 3, val);
m[2][3] = val;
m.get(2, 3) = val;
</pre><p>Matrix body iterators: </p><pre class="fragment">typedef SimpleMatrix&lt;double,3,3&gt; mat3;
mat3 m;
// iterate over the matrix body in row-major order:
for (mat3::iterator i = m.begin(); i != m.end(); i++) {
    *i = ... ;
}
</pre><p>Matrix region iterators: </p><pre class="fragment">typedef SimpleMatrix&lt;double,3,3&gt; mat3;
mat3 m;
Rect2i r = Rect2i(Vec2i(1,1), Vec2i(3,2));
// iterate over the elements in region `r` in row-major order:
for (mat3::region_iterator i = m.region_begin(r); i != m.region_end(r); i++) {
    Vec2i c = i.point();
    *i = f(c, ...);
}
</pre><h2 class="groupheader">Function Documentation</h2>
<a id="gad29282e95cba76934ebf5ebff8dabf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad29282e95cba76934ebf5ebff8dabf1d">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::add </td>
          <td>(</td>
          <td class="paramtype">Matrix *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix addition. Add the corresponding elements of <code>a</code> and <code>b</code>, whose dimensions must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>A writeable matrix, whose dimensions must match <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebd7d99bad76113a8697036b8fe9a5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebd7d99bad76113a8697036b8fe9a5ad">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::add </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix addition. Add the corresponding elements of <code>a</code> and <code>b</code>, whose dimensions must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix containing <code>a + b</code>, usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements. ">SimpleMatrix</a></code>. </dd></dl>

</div>
</div>
<a id="gaae7a0b519bdbfd166ab4d93bece17f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae7a0b519bdbfd166ab4d93bece17f2e">&#9670;&nbsp;</a></span>inv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::inv </td>
          <td>(</td>
          <td class="paramtype">Matrix1 *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix inversion. <code>src</code> and <code>into</code> must be square matrices of the same dimension. If a runtime check for square dimensions fails, a <code>NonsquareMatrixException</code> is raised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix with dimensions equal to <code>src</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A square matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the matrix is singular and could not be inverted, <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="gabcedf9e35d1bb65a05f08a0d657bbbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcedf9e35d1bb65a05f08a0d657bbbfb">&#9670;&nbsp;</a></span>inv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::inv </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix inversion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A square matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">success</td><td>Will be set to <code>false</code> if the matrix was singular and could not be inverted, otherwise will be set to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix containing the inverse of <code>m</code>, or undefined data if <code>m</code> could not be inverted. </dd></dl>

</div>
</div>
<a id="gaece56584613790b7e364cf00b93ee36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece56584613790b7e364cf00b93ee36a">&#9670;&nbsp;</a></span>mtx_aliases_storage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::mtx_aliases_storage </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do two matrices / vectors share storage?</p>
<p>In other words, might writing to one object change the contents of the other? <code>Matrix1</code> and <code>Matrix2</code> must be matrix or vector types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix or vector object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix or vector object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if writing to <code>a</code> may alter <code>b</code> or vice versa; <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga18aa4cc96039ea7bf54d7d9fb25defe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18aa4cc96039ea7bf54d7d9fb25defe4">&#9670;&nbsp;</a></span>mtxcopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::mtxcopy </td>
          <td>(</td>
          <td class="paramtype">Matrix *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the contents of <code>src</code> into <code>into</code>. This function may be optimized to perform better than running <code>std::copy()</code> on some matrix types' iterators. It will also succeed in certain situations where <code>std::copy()</code> would fail (for example when copying the contents of a diagonal matrix to another, any attempt to write off the diagonal will throw an exception).</p>
<p><code>Matrix</code> and <code>Matrix1</code> must be matrix or vector types whose dimensions match. If the dimensions can be determined to mismatch at compile-time, the program is considered invalid and the compilation will fail. If either object has dynamic size, the check will be deferred to runtime, throwing a <code>DimensionMismatchException</code> if the check fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix with dimensions matching <code>src</code>'s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A matrix object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f7b11d56dfce541930313e00471845a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f7b11d56dfce541930313e00471845a">&#9670;&nbsp;</a></span>mul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&amp; geom::mul </td>
          <td>(</td>
          <td class="paramtype">Matrix *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix * matrix and matrix * vector multiplication</p>
<p>This function handles all multiplication between any two types of matrix, or between any matrix and a vector. Thus, <code>Ma</code>, <code>Mb</code>, (the operands) and <code>Md</code> (the destination), may each be either a matrix or a vector. If the left operand is a vector, it is assumed to be a row vector, whereas right vector operands are column vectors.</p>
<p>This function ensures that all compile-time checkable dimensions agree&ndash; that is to say, that <code>(a x b) * (b x c) = (a x c)</code> holds. If any object has a dynamic size, then the check will be deferred to runtime, and a DimensionMismatchException thrown if the check fails. A compile-time dimension mismatch implies the program is invalid and compilation will error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix or vector with dimensions <code>(a.rows() x b.cols())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object or vector with dimension <code>(N x b.rows())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object or vector with dimension <code>(a.cols() x N)</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d61c9c78d6cfeec7f676ebbf028970c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d61c9c78d6cfeec7f676ebbf028970c">&#9670;&nbsp;</a></span>mul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::mul </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix multiplication.</p>
<p><code>Matrix1</code> and <code>Matrix2</code> may either be matrices or vectors. Left operands are, if vectors, assumed to be rows, while right operands will be treated as columns. The dimensions of <code>a</code> and <code>b</code> must satisfy <code>(a x b) * (b x c)</code>. If the dimensions can be determined to mismatch at compile time, the program is considered invalid and will not compile. If either argument has dynamic size, the dimension check will be performed at runtime, raising a <code>DimensionMismatchException</code> if it fails.</p>
<p>The return type will be chosen appropriately based on the arguments, and will have dimension <code>(a x c)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object or vector with dimension <code>(N x b.rows())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object or vector with dimension <code>(a.cols() x N)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix or vector object containing the result of <code>a * b</code>. </dd></dl>

</div>
</div>
<a id="gaedf95ce414e21e18e3da3f526b52dad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf95ce414e21e18e3da3f526b52dad7">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix != matrix.</p>
<p>Matrices <code>a</code> and <code>b</code> are unequal unless <code>a</code> and <code>b</code> have the same dimension and all corresponding elements are equal. </p>

</div>
</div>
<a id="ga99c139a4368bc2abeea5b2d39a0fbb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c139a4368bc2abeea5b2d39a0fbb5c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::operator* </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>scalar * matrix</p>
<p>All elements of <code>m</code> are multiplied by <code>k</code>. <code>Matrix</code> must be a matrix type, and <code>U</code> must satisfy <code>boost::is_scalar&lt;U&gt;</code>. </p>

</div>
</div>
<a id="gaba31a5d092076a91ccdadf0072e80fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba31a5d092076a91ccdadf0072e80fdb">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::operator* </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix * scalar</p>
<p>All elements of <code>m</code> are multiplied by <code>k</code>. <code>Matrix</code> must be a matrix type, and <code>U</code> must satisfy <code>boost::is_scalar&lt;U&gt;</code>. </p>

</div>
</div>
<a id="gadb844d5ef54addfd4be39a3cc171940a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb844d5ef54addfd4be39a3cc171940a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::operator* </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix * matrix</p>
<p>Matrix multiplication is performed on <code>a</code> and <code>b</code>.</p>
<p><code>Matrix1</code> and <code>Matrix2</code> may either be matrices or vectors (but may not <em>both</em> be vectors; this is handled by a different multiplication operator). Left operands are, if vectors, assumed to be rows, while right operands will be treated as columns. The dimensions of <code>a</code> and <code>b</code> must satisfy <code>(a x b) * (b x c)</code>. If the dimensions can be determined to mismatch at compile time, the program is considered invalid and will not compile. If either argument has dynamic size, the dimension check will be performed at runtime, raising a <code>DimensionMismatchException</code> if it fails.</p>
<p>The return type will be chosen appropriately based on the arguments, and will have dimension <code>(a x c)</code>. </p>

</div>
</div>
<a id="gaa1a2a9df9697a40eeb4bdf795f35b3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1a2a9df9697a40eeb4bdf795f35b3c6">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix + matrix</p>
<p>Add the elements of <code>a</code> and <code>b</code>. The return type will be chosen appropriately based on the arguments (usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements. ">SimpleMatrix</a></code>). <code>Matrix1</code> and <code>Matrix2</code> must both be matrix types. </p>

</div>
</div>
<a id="ga204dfbeacaf70f1712bde20a2b3806b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga204dfbeacaf70f1712bde20a2b3806b3">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::operator- </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix - matrix.</p>
<p>Subtract the elements of <code>b</code> from <code>a</code>. The return type will be chosen appropriately based on the arguments (usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements. ">SimpleMatrix</a></code>). <code>Matrix1</code> and <code>Matrix2</code> must both be matrix types. </p>

</div>
</div>
<a id="ga9bc066c784d93944802791afbb4d8bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bc066c784d93944802791afbb4d8bde">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::operator== </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix == matrix.</p>
<p>Matrices <code>a</code> and <code>b</code> are equal if and only if <code>a</code> and <code>b</code> have the same dimension and all corresponding elements are equal. <code>Matrix1</code> and <code>Matrix2</code> must both be matrix types. </p>

</div>
</div>
<a id="gaaef5d783aa86e83c9666737f6b496cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaef5d783aa86e83c9666737f6b496cd3">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::scale </td>
          <td>(</td>
          <td class="paramtype">Matrix1 *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar muliplication on matrices. In other words, multiply all the elements of <code>m</code> by scalar value <code>k</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>A writeable matrix, whose dimensions must match those of <code>m</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Scalar constant (whose type satisfies <code>boost::is_scalar&lt;U&gt;</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix object to be scaled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga432043158b759a37a48d1c1855f863c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga432043158b759a37a48d1c1855f863c3">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::scale </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar muliplication on matrices. In other words, multiply all the elements of <code>m</code> by scalar value <code>k</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Scalar constant (whose type satisfies <code>boost::is_scalar&lt;U&gt;</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix object to be scaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scaled copy of <code>m</code>. </dd></dl>

</div>
</div>
<a id="gaedd89060fc778b8fdccc689754607925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedd89060fc778b8fdccc689754607925">&#9670;&nbsp;</a></span>sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::sub </td>
          <td>(</td>
          <td class="paramtype">Matrix *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix subtraction. Subtract the corresponding elements of <code>b</code> from <code>a</code>'s. The dimensions of <code>a</code> and <code>b</code> must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>A writeable matrix, whose dimensions must match <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab37c042365e8f243c7b7fa077e690995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab37c042365e8f243c7b7fa077e690995">&#9670;&nbsp;</a></span>sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::sub </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix subtraction. Subtract the corresponding elements of <code>b</code> from <code>a</code>'s. The dimensions of <code>a</code> and <code>b</code> must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Matrix object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix containing <code>a - b</code>, usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements. ">SimpleMatrix</a></code>. </dd></dl>

</div>
</div>
<a id="gafd2d064d06760e230385ca5fcc0a29fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd2d064d06760e230385ca5fcc0a29fd">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::transpose </td>
          <td>(</td>
          <td class="paramtype">Matrix1 *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix transpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix with dimensions <code>(m.cols(), m.rows())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabd880a0d5fc18a0657bdff67c20c495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabd880a0d5fc18a0657bdff67c20c495">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix geom::transpose </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix transpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A matrix object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A transposed copy of <code>m</code>, of type appropriate for the argument, usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements. ">SimpleMatrix</a></code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 30 2018 00:22:31 for geomc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
