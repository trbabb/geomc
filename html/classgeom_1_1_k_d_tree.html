<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geomc: KDTree&lt; T, N, Object, NodeData &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">geomc<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A c++ linear algebra template library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeom.html">geom</a></li><li class="navelem"><a class="el" href="classgeom_1_1_k_d_tree.html">KDTree</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgeom_1_1_k_d_tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">KDTree&lt; T, N, Object, NodeData &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__shape.html">Shape</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A hierarchical spatial index.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_k_d_tree_8h_source.html">geomc/shape/KDTree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_k_d_tree_1_1_k_d_node_iterator.html">KDNodeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgeom_1_1_k_d_tree_1_1_k_d_structure_params.html">KDStructureParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure encapsulating the tree balancing parameters.  <a href="structgeom_1_1_k_d_tree_1_1_k_d_structure_params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3a547016e79606475528bdc11e04e4fa" id="r_a3a547016e79606475528bdc11e04e4fa"><td class="memItemLeft" align="right" valign="top"><a id="a3a547016e79606475528bdc11e04e4fa" name="a3a547016e79606475528bdc11e04e4fa"></a>
typedef <a class="el" href="classgeom_1_1_k_d_tree_1_1_k_d_node_iterator.html">KDNodeIterator</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_iterator</b></td></tr>
<tr class="memdesc:a3a547016e79606475528bdc11e04e4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the internal tree nodes. <br /></td></tr>
<tr class="separator:a3a547016e79606475528bdc11e04e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd5a4b82b4d4cc5c6e16080357c9478" id="r_a9bd5a4b82b4d4cc5c6e16080357c9478"><td class="memItemLeft" align="right" valign="top"><a id="a9bd5a4b82b4d4cc5c6e16080357c9478" name="a9bd5a4b82b4d4cc5c6e16080357c9478"></a>
typedef <a class="el" href="classgeom_1_1_k_d_tree_1_1_k_d_node_iterator.html">KDNodeIterator</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_node_iterator</b></td></tr>
<tr class="memdesc:a9bd5a4b82b4d4cc5c6e16080357c9478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over the internal tree nodes. <br /></td></tr>
<tr class="separator:a9bd5a4b82b4d4cc5c6e16080357c9478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad673d0ca92c7b280ed0ad6260a2640d4" id="r_ad673d0ca92c7b280ed0ad6260a2640d4"><td class="memItemLeft" align="right" valign="top"><a id="ad673d0ca92c7b280ed0ad6260a2640d4" name="ad673d0ca92c7b280ed0ad6260a2640d4"></a>
typedef std::list&lt; Object &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>object_iterator</b></td></tr>
<tr class="memdesc:ad673d0ca92c7b280ed0ad6260a2640d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over objects. <br /></td></tr>
<tr class="separator:ad673d0ca92c7b280ed0ad6260a2640d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffe937e55020131413727f5edc4d3fc" id="r_aaffe937e55020131413727f5edc4d3fc"><td class="memItemLeft" align="right" valign="top"><a id="aaffe937e55020131413727f5edc4d3fc" name="aaffe937e55020131413727f5edc4d3fc"></a>
typedef std::list&lt; Object &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_object_iterator</b></td></tr>
<tr class="memdesc:aaffe937e55020131413727f5edc4d3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over objects. <br /></td></tr>
<tr class="separator:aaffe937e55020131413727f5edc4d3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a463d84f3ca9e023ddb6c0606761f15c6" id="r_a463d84f3ca9e023ddb6c0606761f15c6"><td class="memItemLeft" align="right" valign="top"><a id="a463d84f3ca9e023ddb6c0606761f15c6" name="a463d84f3ca9e023ddb6c0606761f15c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>KDTree</b> ()</td></tr>
<tr class="memdesc:a463d84f3ca9e023ddb6c0606761f15c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="classgeom_1_1_k_d_tree.html" title="A hierarchical spatial index.">KDTree</a> with the default structure parameters for this dimension. <br /></td></tr>
<tr class="separator:a463d84f3ca9e023ddb6c0606761f15c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb7d438b159566e99f2e2c010ba206e" id="r_a6cb7d438b159566e99f2e2c010ba206e"><td class="memItemLeft" align="right" valign="top"><a id="a6cb7d438b159566e99f2e2c010ba206e" name="a6cb7d438b159566e99f2e2c010ba206e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>KDTree</b> (Object *objs, index_t nobjs, const <a class="el" href="structgeom_1_1_k_d_tree_1_1_k_d_structure_params.html">KDStructureParams</a> params=DefaultParameters)</td></tr>
<tr class="memdesc:a6cb7d438b159566e99f2e2c010ba206e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classgeom_1_1_k_d_tree.html" title="A hierarchical spatial index.">KDTree</a> initialized with <code>objs</code>. <br /></td></tr>
<tr class="separator:a6cb7d438b159566e99f2e2c010ba206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91a812258b10f969331de5a8d10f989" id="r_ab91a812258b10f969331de5a8d10f989"><td class="memTemplParams" colspan="2"><a id="ab91a812258b10f969331de5a8d10f989" name="ab91a812258b10f969331de5a8d10f989"></a>
template&lt;typename ObjectIterator &gt; </td></tr>
<tr class="memitem:ab91a812258b10f969331de5a8d10f989"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KDTree</b> (ObjectIterator <a class="el" href="#ad82100fde5705b4b7f0f3e473a3b7a68">begin</a>, ObjectIterator <a class="el" href="#a4522f956a262bb379743238c48041bd4">end</a>, const <a class="el" href="structgeom_1_1_k_d_tree_1_1_k_d_structure_params.html">KDStructureParams</a> params=DefaultParameters)</td></tr>
<tr class="memdesc:ab91a812258b10f969331de5a8d10f989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classgeom_1_1_k_d_tree.html" title="A hierarchical spatial index.">KDTree</a> initialized with the objects contained in the interval [begin, end). <br /></td></tr>
<tr class="separator:ab91a812258b10f969331de5a8d10f989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec358712bd195d17e7439aa0c9f9ed1" id="r_a8ec358712bd195d17e7439aa0c9f9ed1"><td class="memItemLeft" align="right" valign="top"><a id="a8ec358712bd195d17e7439aa0c9f9ed1" name="a8ec358712bd195d17e7439aa0c9f9ed1"></a>
index_t&#160;</td><td class="memItemRight" valign="bottom"><b>nobjects</b> () const</td></tr>
<tr class="memdesc:a8ec358712bd195d17e7439aa0c9f9ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of data objects in the tree. <br /></td></tr>
<tr class="separator:a8ec358712bd195d17e7439aa0c9f9ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82100fde5705b4b7f0f3e473a3b7a68" id="r_ad82100fde5705b4b7f0f3e473a3b7a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad82100fde5705b4b7f0f3e473a3b7a68">begin</a> ()</td></tr>
<tr class="separator:ad82100fde5705b4b7f0f3e473a3b7a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4522f956a262bb379743238c48041bd4" id="r_a4522f956a262bb379743238c48041bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4522f956a262bb379743238c48041bd4">end</a> ()</td></tr>
<tr class="separator:a4522f956a262bb379743238c48041bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00de11b29bcbc81323bce607802b472d" id="r_a00de11b29bcbc81323bce607802b472d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9bd5a4b82b4d4cc5c6e16080357c9478">const_node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00de11b29bcbc81323bce607802b472d">begin</a> () const</td></tr>
<tr class="separator:a00de11b29bcbc81323bce607802b472d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe50ea780c22d59588c69b36842be72a" id="r_abe50ea780c22d59588c69b36842be72a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9bd5a4b82b4d4cc5c6e16080357c9478">const_node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe50ea780c22d59588c69b36842be72a">end</a> () const</td></tr>
<tr class="separator:abe50ea780c22d59588c69b36842be72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac526307c77b26e504c8c447a98e85699" id="r_ac526307c77b26e504c8c447a98e85699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad673d0ca92c7b280ed0ad6260a2640d4">object_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac526307c77b26e504c8c447a98e85699">insert</a> (const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;node, const Object &amp;obj)</td></tr>
<tr class="separator:ac526307c77b26e504c8c447a98e85699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6494f90953df3fc356458135285bc3b" id="r_ab6494f90953df3fc356458135285bc3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad673d0ca92c7b280ed0ad6260a2640d4">object_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6494f90953df3fc356458135285bc3b">erase</a> (const <a class="el" href="#ad673d0ca92c7b280ed0ad6260a2640d4">object_iterator</a> &amp;obj, const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;node)</td></tr>
<tr class="separator:ab6494f90953df3fc356458135285bc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b1a172b3f129d432a6e2d60a93e6d3" id="r_af3b1a172b3f129d432a6e2d60a93e6d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3b1a172b3f129d432a6e2d60a93e6d3">rebalance</a> (const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;node)</td></tr>
<tr class="separator:af3b1a172b3f129d432a6e2d60a93e6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2bf93497a4976b9f6793d8666b409c" id="r_aac2bf93497a4976b9f6793d8666b409c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac2bf93497a4976b9f6793d8666b409c">rebalance</a> ()</td></tr>
<tr class="separator:aac2bf93497a4976b9f6793d8666b409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab992f78cab305bbc8a871167e0872879" id="r_ab992f78cab305bbc8a871167e0872879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab992f78cab305bbc8a871167e0872879">rebalance</a> (const <a class="el" href="structgeom_1_1_k_d_tree_1_1_k_d_structure_params.html">KDStructureParams</a> &amp;newParams)</td></tr>
<tr class="separator:ab992f78cab305bbc8a871167e0872879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f770d47abea5b9cba92e5710af6ae04" id="r_a0f770d47abea5b9cba92e5710af6ae04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f770d47abea5b9cba92e5710af6ae04">erase</a> (const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;node)</td></tr>
<tr class="separator:a0f770d47abea5b9cba92e5710af6ae04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6288b6c241eafc6ad98ab1fe97587215" id="r_a6288b6c241eafc6ad98ab1fe97587215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6288b6c241eafc6ad98ab1fe97587215">clear</a> (const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;node)</td></tr>
<tr class="separator:a6288b6c241eafc6ad98ab1fe97587215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdadb5be5024ffa343d7f3cbafc5e558" id="r_abdadb5be5024ffa343d7f3cbafc5e558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdadb5be5024ffa343d7f3cbafc5e558">flatten</a> (const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;node)</td></tr>
<tr class="separator:abdadb5be5024ffa343d7f3cbafc5e558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992a8da924b065e29b9393011bc813ab" id="r_a992a8da924b065e29b9393011bc813ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a992a8da924b065e29b9393011bc813ab">insertChild</a> (const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;node)</td></tr>
<tr class="separator:a992a8da924b065e29b9393011bc813ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4399e00891da3fd3458c707378410bc" id="r_ab4399e00891da3fd3458c707378410bc"><td class="memItemLeft" align="right" valign="top">const Object &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4399e00891da3fd3458c707378410bc">nearest</a> (const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; &amp;p) const</td></tr>
<tr class="separator:ab4399e00891da3fd3458c707378410bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d5f315571ab2c510ee4c50ee65f39e" id="r_a11d5f315571ab2c510ee4c50ee65f39e"><td class="memItemLeft" align="right" valign="top">Object &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d5f315571ab2c510ee4c50ee65f39e">nearest</a> (const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; &amp;p)</td></tr>
<tr class="separator:a11d5f315571ab2c510ee4c50ee65f39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae678fd69d583290dfd8cdddd2b8ae21e" id="r_ae678fd69d583290dfd8cdddd2b8ae21e"><td class="memItemLeft" align="right" valign="top"><a id="ae678fd69d583290dfd8cdddd2b8ae21e" name="ae678fd69d583290dfd8cdddd2b8ae21e"></a>
const <a class="el" href="structgeom_1_1_k_d_tree_1_1_k_d_structure_params.html">KDStructureParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getStructureParams</b> ()</td></tr>
<tr class="memdesc:ae678fd69d583290dfd8cdddd2b8ae21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters describing the current tree-balancing strategy. <br /></td></tr>
<tr class="separator:ae678fd69d583290dfd8cdddd2b8ae21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, index_t N, typename Object, typename NodeData = void*&gt;<br />
class geom::KDTree&lt; T, N, Object, NodeData &gt;</div><p>A hierarchical spatial index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type. </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of data. </td></tr>
    <tr><td class="paramname">Object</td><td>Spatial object to be indexed. May be a <code><a class="el" href="classgeom_1_1_vec.html" title="A tuple of N elements of type T.">Vec</a>&lt;T,N&gt;</code>, a <code><a class="el" href="classgeom_1_1_bounded.html" title="Base class describing shapes with finite extents in N dimensions.">Bounded</a>&lt;T,N&gt;</code>, or a <code>std::pair&lt;K,V&gt;</code> with <code>K</code> either of the former. </td></tr>
    <tr><td class="paramname">NodeData</td><td>Optional data to store with each internal node of the tree. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad82100fde5705b4b7f0f3e473a3b7a68" name="ad82100fde5705b4b7f0f3e473a3b7a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82100fde5705b4b7f0f3e473a3b7a68">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing at the root tree node. Use <code>+i</code> and <code>-i</code> to ascend and descend to the first-child and parent nodes respectively. <code>++i</code> and <code>--i</code> navigate the tree in breadth-first order, and can therefore be used to find the next and previous siblings. </p>

</div>
</div>
<a id="a00de11b29bcbc81323bce607802b472d" name="a00de11b29bcbc81323bce607802b472d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00de11b29bcbc81323bce607802b472d">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9bd5a4b82b4d4cc5c6e16080357c9478">const_node_iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a const iterator pointing at the root tree node. Use <code>+i</code> and <code>-i</code> to ascend and descend to the first-child and parent nodes respectively. <code>++i</code> and <code>--i</code> navigate the tree in breadth-first order, and can therefore be used to find the next and previous siblings. </p>

</div>
</div>
<a id="a6288b6c241eafc6ad98ab1fe97587215" name="a6288b6c241eafc6ad98ab1fe97587215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6288b6c241eafc6ad98ab1fe97587215">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Empty the given node of all its objects, and delete all its child nodes. Runs in <code>O(n)</code> time on the node count of the emptied subtree.</p>
<p>Any iterators pointing to nodes or objects in the deleted subtree are invalidated. </p>

</div>
</div>
<a id="a4522f956a262bb379743238c48041bd4" name="a4522f956a262bb379743238c48041bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4522f956a262bb379743238c48041bd4">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing beyond the last node in the tree; conceptually the parent of the root. </p>

</div>
</div>
<a id="abe50ea780c22d59588c69b36842be72a" name="abe50ea780c22d59588c69b36842be72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe50ea780c22d59588c69b36842be72a">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9bd5a4b82b4d4cc5c6e16080357c9478">const_node_iterator</a> end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a const iterator pointing beyond the last node in the tree in breadth-first order; conceptually the parent of the root. </p>

</div>
</div>
<a id="a0f770d47abea5b9cba92e5710af6ae04" name="a0f770d47abea5b9cba92e5710af6ae04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f770d47abea5b9cba92e5710af6ae04">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the given node, all of its children, and all the objects it contains. Runs in <code>O(n)</code> time on the node count of the deleted subtree.</p>
<p>The root node cannot be erased. If it is passed as an argument, it is returned without deletion.</p>
<p>Any iterators pointing to this node, any of its descendents, or the objects contained therein are invalidated. If deleting this node leaves one remaining sibling, then the sibling will be absorbed into its parent and its iterator will be invalidated.</p>
<dl class="section return"><dt>Returns</dt><dd>The node after the deleted node, in breadth-first order. </dd></dl>

</div>
</div>
<a id="ab6494f90953df3fc356458135285bc3b" name="ab6494f90953df3fc356458135285bc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6494f90953df3fc356458135285bc3b">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad673d0ca92c7b280ed0ad6260a2640d4">object_iterator</a> erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad673d0ca92c7b280ed0ad6260a2640d4">object_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the object at the given iterator from the given leaf node.</p>
<p>If the node is not a leaf or does not contain the object, no change is made and the original iterator is returned. Otherwise, an iterator to the next object is returned.</p>
<p>Both iterators may be invalidated by this operation. </p>

</div>
</div>
<a id="abdadb5be5024ffa343d7f3cbafc5e558" name="abdadb5be5024ffa343d7f3cbafc5e558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdadb5be5024ffa343d7f3cbafc5e558">&#9670;&#160;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flatten </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete all the child nodes of the given node, and assign all the objects below to it. Runs in <code>O(n)</code> time on the node count of the emptied subtree.</p>
<p>Any iterators pointing to nodes in the deleted subtree are invalidated. </p>

</div>
</div>
<a id="ac526307c77b26e504c8c447a98e85699" name="ac526307c77b26e504c8c447a98e85699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac526307c77b26e504c8c447a98e85699">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad673d0ca92c7b280ed0ad6260a2640d4">object_iterator</a> insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Object &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert the given object into the tree under the given node. The tree will be descended recursively until the best leaf is found. </p>

</div>
</div>
<a id="a992a8da924b065e29b9393011bc813ab" name="a992a8da924b065e29b9393011bc813ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992a8da924b065e29b9393011bc813ab">&#9670;&#160;</a></span>insertChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> insertChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a new tree node under the given node. If the created node is the first child of <code>node</code>, then it will contain all of <code>node</code>'s objects, otherwise it will be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>The inserted node. </dd></dl>

</div>
</div>
<a id="a11d5f315571ab2c510ee4c50ee65f39e" name="a11d5f315571ab2c510ee4c50ee65f39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d5f315571ab2c510ee4c50ee65f39e">&#9670;&#160;</a></span>nearest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Object &amp; nearest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the object in the tree closest to the query point <code>q</code>. </p>

</div>
</div>
<a id="ab4399e00891da3fd3458c707378410bc" name="ab4399e00891da3fd3458c707378410bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4399e00891da3fd3458c707378410bc">&#9670;&#160;</a></span>nearest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Object &amp; nearest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the object in the tree closest to the query point <code>q</code>. </p>

</div>
</div>
<a id="aac2bf93497a4976b9f6793d8666b409c" name="aac2bf93497a4976b9f6793d8666b409c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2bf93497a4976b9f6793d8666b409c">&#9670;&#160;</a></span>rebalance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebalance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rebuild the entire tree.</p>
<p>All iterators are invalidated. </p>

</div>
</div>
<a id="ab992f78cab305bbc8a871167e0872879" name="ab992f78cab305bbc8a871167e0872879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab992f78cab305bbc8a871167e0872879">&#9670;&#160;</a></span>rebalance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebalance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgeom_1_1_k_d_tree_1_1_k_d_structure_params.html">KDStructureParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newParams</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the balancing parameters of the tree, and rebuild it according to the new artings. </p>

</div>
</div>
<a id="af3b1a172b3f129d432a6e2d60a93e6d3" name="af3b1a172b3f129d432a6e2d60a93e6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b1a172b3f129d432a6e2d60a93e6d3">&#9670;&#160;</a></span>rebalance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , index_t N, typename Object , typename NodeData  = void*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebalance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3a547016e79606475528bdc11e04e4fa">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rebuild the given subtree according to its current balancing parameters, in <code>O(n log(n))</code> time. If rebuilding from the root, it is more efficient to call <code><a class="el" href="#aac2bf93497a4976b9f6793d8666b409c">rebalance()</a></code> with no args.</p>
<p>Any iterators pointing to descendents of the given node are invalidated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>geomc/shape/<a class="el" href="_k_d_tree_8h_source.html">KDTree.h</a></li>
<li>geomc/shape/<a class="el" href="_shape_types_8h_source.html">ShapeTypes.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 18 2025 22:00:27 for geomc by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
