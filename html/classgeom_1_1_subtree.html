<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geomc: Subtree&lt; NodeItem, LeafItem &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">geomc
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A c++ linear algebra template library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeom.html">geom</a></li><li class="navelem"><a class="el" href="classgeom_1_1_subtree.html">Subtree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classgeom_1_1_subtree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Subtree&lt; NodeItem, LeafItem &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__storage.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A non-const iterator to a subtree.  
 <a href="classgeom_1_1_subtree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_tree_8h_source.html">geomc/Tree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Subtree&lt; NodeItem, LeafItem &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgeom_1_1_subtree.png" usemap="#Subtree_3C_20NodeItem_2C_20LeafItem_20_3E_map" alt=""/>
  <map id="Subtree_3C_20NodeItem_2C_20LeafItem_20_3E_map" name="Subtree_3C_20NodeItem_2C_20LeafItem_20_3E_map">
<area href="classgeom_1_1_subtree_base.html" title="Base class for all iterators into Trees. " alt="SubtreeBase&lt; NodeItem, LeafItem, Const &gt;" shape="rect" coords="0,0,252,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7c32a864c1c2ee5ef60d3e5eeff7aa8f"><td class="memItemLeft" align="right" valign="top"><a id="a7c32a864c1c2ee5ef60d3e5eeff7aa8f"></a>
typedef <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a7c32a864c1c2ee5ef60d3e5eeff7aa8f">iterator</a></td></tr>
<tr class="memdesc:a7c32a864c1c2ee5ef60d3e5eeff7aa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (possibly const) iterator over subtrees. <br /></td></tr>
<tr class="separator:a7c32a864c1c2ee5ef60d3e5eeff7aa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd58c336bc87a751dc6be5b23328231"><td class="memItemLeft" align="right" valign="top"><a id="a6cd58c336bc87a751dc6be5b23328231"></a>
typedef <a class="el" href="classgeom_1_1_const_subtree.html">ConstSubtree</a>&lt; NodeItem, LeafItem &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a6cd58c336bc87a751dc6be5b23328231">const_iterator</a></td></tr>
<tr class="memdesc:a6cd58c336bc87a751dc6be5b23328231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over subtrees. <br /></td></tr>
<tr class="separator:a6cd58c336bc87a751dc6be5b23328231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f4b7955d1888fe47dbc9e682456ac5"><td class="memItemLeft" align="right" valign="top"><a id="a75f4b7955d1888fe47dbc9e682456ac5"></a>
typedef std::conditional&lt; Const, ConstItemRef, ItemRef &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a></td></tr>
<tr class="memdesc:a75f4b7955d1888fe47dbc9e682456ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (possibly const) iterator to <code>LeafItem</code>s. <br /></td></tr>
<tr class="separator:a75f4b7955d1888fe47dbc9e682456ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951804461d164a1dd2e7dd74721ff42"><td class="memItemLeft" align="right" valign="top"><a id="a3951804461d164a1dd2e7dd74721ff42"></a>
typedef ConstItemRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a3951804461d164a1dd2e7dd74721ff42">const_item_iterator</a></td></tr>
<tr class="memdesc:a3951804461d164a1dd2e7dd74721ff42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator to <code>LeafItem</code>s. <br /></td></tr>
<tr class="separator:a3951804461d164a1dd2e7dd74721ff42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c1070af17f7a056d7152475eb71515"><td class="memItemLeft" align="right" valign="top"><a id="a13c1070af17f7a056d7152475eb71515"></a>
typedef NodeItem&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a13c1070af17f7a056d7152475eb71515">value_type</a></td></tr>
<tr class="memdesc:a13c1070af17f7a056d7152475eb71515"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tree's <code>NodeItem</code> type. <br /></td></tr>
<tr class="separator:a13c1070af17f7a056d7152475eb71515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f200ee652f18b2412fa000a8fedf794"><td class="memItemLeft" align="right" valign="top"><a id="a4f200ee652f18b2412fa000a8fedf794"></a>
typedef std::conditional&lt; Const, const NodeItem &amp;, NodeItem &amp;&gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a4f200ee652f18b2412fa000a8fedf794">reference</a></td></tr>
<tr class="memdesc:a4f200ee652f18b2412fa000a8fedf794"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (possibly const) reference to the tree's <code>NodeItem</code> type. <br /></td></tr>
<tr class="separator:a4f200ee652f18b2412fa000a8fedf794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b56f1a6d89eb779842804b57da76d56"><td class="memItemLeft" align="right" valign="top"><a id="a8b56f1a6d89eb779842804b57da76d56"></a>
typedef const NodeItem &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a8b56f1a6d89eb779842804b57da76d56">const_reference</a></td></tr>
<tr class="memdesc:a8b56f1a6d89eb779842804b57da76d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reference to the tree's <code>NodeItem</code> type. <br /></td></tr>
<tr class="separator:a8b56f1a6d89eb779842804b57da76d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fede1dd56a91627717fcbf0ef1bcb6e"><td class="memItemLeft" align="right" valign="top"><a id="a8fede1dd56a91627717fcbf0ef1bcb6e"></a>
typedef std::conditional&lt; Const, const NodeItem *, NodeItem *&gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a8fede1dd56a91627717fcbf0ef1bcb6e">pointer</a></td></tr>
<tr class="memdesc:a8fede1dd56a91627717fcbf0ef1bcb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (possibly const) pointer to the tree's <code>NodeItem</code> type. <br /></td></tr>
<tr class="separator:a8fede1dd56a91627717fcbf0ef1bcb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904e4d810d2e5eea75b58c66e08c0236"><td class="memItemLeft" align="right" valign="top"><a id="a904e4d810d2e5eea75b58c66e08c0236"></a>
typedef <a class="el" href="classgeom_1_1_tree.html">Tree</a>&lt; NodeItem, LeafItem &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a904e4d810d2e5eea75b58c66e08c0236">tree_t</a></td></tr>
<tr class="memdesc:a904e4d810d2e5eea75b58c66e08c0236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of tree into which this iterator points. <br /></td></tr>
<tr class="separator:a904e4d810d2e5eea75b58c66e08c0236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdd13f89f59c2e4cbe107005e05ca27"><td class="memItemLeft" align="right" valign="top"><a id="abfdd13f89f59c2e4cbe107005e05ca27"></a>
typedef std::iterator_traits&lt; NodeRef &gt;::<a class="el" href="classgeom_1_1_subtree_base.html#abfdd13f89f59c2e4cbe107005e05ca27">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#abfdd13f89f59c2e4cbe107005e05ca27">difference_type</a></td></tr>
<tr class="memdesc:abfdd13f89f59c2e4cbe107005e05ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator difference type. <br /></td></tr>
<tr class="separator:abfdd13f89f59c2e4cbe107005e05ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f92646ae1198b1e6cccf1245b0a9a5"><td class="memItemLeft" align="right" valign="top"><a id="ad0f92646ae1198b1e6cccf1245b0a9a5"></a>
typedef std::iterator_traits&lt; NodeRef &gt;::<a class="el" href="classgeom_1_1_subtree_base.html#ad0f92646ae1198b1e6cccf1245b0a9a5">iterator_category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#ad0f92646ae1198b1e6cccf1245b0a9a5">iterator_category</a></td></tr>
<tr class="memdesc:ad0f92646ae1198b1e6cccf1245b0a9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator category. <br /></td></tr>
<tr class="separator:ad0f92646ae1198b1e6cccf1245b0a9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27fbff87cc12f43330d1b4c48e93b0bd"><td class="memItemLeft" align="right" valign="top"><a id="a27fbff87cc12f43330d1b4c48e93b0bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a27fbff87cc12f43330d1b4c48e93b0bd">Subtree</a> (const <a class="el" href="classgeom_1_1_subtree.html">Subtree</a>&lt; NodeItem, LeafItem &gt; &amp;other)=default</td></tr>
<tr class="memdesc:a27fbff87cc12f43330d1b4c48e93b0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a duplicate iterator to the same node of the same tree. <br /></td></tr>
<tr class="separator:a27fbff87cc12f43330d1b4c48e93b0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591440a4ec3be574e382eae31e0589b5"><td class="memItemLeft" align="right" valign="top"><a id="a591440a4ec3be574e382eae31e0589b5"></a>
std::conditional&lt; Const, const <a class="el" href="classgeom_1_1_subtree_base.html#a904e4d810d2e5eea75b58c66e08c0236">tree_t</a> &amp;, <a class="el" href="classgeom_1_1_subtree_base.html#a904e4d810d2e5eea75b58c66e08c0236">tree_t</a> &amp; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a591440a4ec3be574e382eae31e0589b5">tree</a> () const</td></tr>
<tr class="memdesc:a591440a4ec3be574e382eae31e0589b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the tree into which this iterator points. <br /></td></tr>
<tr class="separator:a591440a4ec3be574e382eae31e0589b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dd8856ad445b1f8170d98309e63b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a85dd8856ad445b1f8170d98309e63b50">parent</a> () const</td></tr>
<tr class="memdesc:a85dd8856ad445b1f8170d98309e63b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent node.  <a href="#a85dd8856ad445b1f8170d98309e63b50">More...</a><br /></td></tr>
<tr class="separator:a85dd8856ad445b1f8170d98309e63b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c1b95c89ea40b8afb4def6575e20c4"><td class="memItemLeft" align="right" valign="top"><a id="a46c1b95c89ea40b8afb4def6575e20c4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a46c1b95c89ea40b8afb4def6575e20c4">is_root</a> () const</td></tr>
<tr class="memdesc:a46c1b95c89ea40b8afb4def6575e20c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this node is the root of the entire tree. <br /></td></tr>
<tr class="separator:a46c1b95c89ea40b8afb4def6575e20c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d674b8ff201810bab0070967c33f40b"><td class="memItemLeft" align="right" valign="top"><a id="a5d674b8ff201810bab0070967c33f40b"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a5d674b8ff201810bab0070967c33f40b">operator+</a> ()</td></tr>
<tr class="memdesc:a5d674b8ff201810bab0070967c33f40b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>+i</code>: Become first child <br /></td></tr>
<tr class="separator:a5d674b8ff201810bab0070967c33f40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5909e8467eba46aa9dd40e5064e0c970"><td class="memItemLeft" align="right" valign="top"><a id="a5909e8467eba46aa9dd40e5064e0c970"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a5909e8467eba46aa9dd40e5064e0c970">operator-</a> ()</td></tr>
<tr class="memdesc:a5909e8467eba46aa9dd40e5064e0c970"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>-i</code>: Become parent <br /></td></tr>
<tr class="separator:a5909e8467eba46aa9dd40e5064e0c970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0753dd11175381f49f5aec6d953f734e"><td class="memItemLeft" align="right" valign="top"><a id="a0753dd11175381f49f5aec6d953f734e"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a0753dd11175381f49f5aec6d953f734e">operator++</a> ()</td></tr>
<tr class="memdesc:a0753dd11175381f49f5aec6d953f734e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>++i</code>: Become next sibling <br /></td></tr>
<tr class="separator:a0753dd11175381f49f5aec6d953f734e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a912e406da2b8455e2a8dd8f3dbf87"><td class="memItemLeft" align="right" valign="top"><a id="ad2a912e406da2b8455e2a8dd8f3dbf87"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#ad2a912e406da2b8455e2a8dd8f3dbf87">operator++</a> (int)</td></tr>
<tr class="memdesc:ad2a912e406da2b8455e2a8dd8f3dbf87"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>i++</code>: Become next sibling <br /></td></tr>
<tr class="separator:ad2a912e406da2b8455e2a8dd8f3dbf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af989be7495fbf97878b6e2dbdb72276f"><td class="memItemLeft" align="right" valign="top"><a id="af989be7495fbf97878b6e2dbdb72276f"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#af989be7495fbf97878b6e2dbdb72276f">operator--</a> ()</td></tr>
<tr class="memdesc:af989be7495fbf97878b6e2dbdb72276f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>--i</code>: Become previous sibling <br /></td></tr>
<tr class="separator:af989be7495fbf97878b6e2dbdb72276f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e0fdeec319750cf8ecbcf888624394"><td class="memItemLeft" align="right" valign="top"><a id="a11e0fdeec319750cf8ecbcf888624394"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a11e0fdeec319750cf8ecbcf888624394">operator--</a> (int)</td></tr>
<tr class="memdesc:a11e0fdeec319750cf8ecbcf888624394"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>i--</code>: Become previous sibling <br /></td></tr>
<tr class="separator:a11e0fdeec319750cf8ecbcf888624394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644ab76d5f1dffea15710a549a80e378"><td class="memItemLeft" align="right" valign="top"><a id="a644ab76d5f1dffea15710a549a80e378"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a644ab76d5f1dffea15710a549a80e378">operator==</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;other) const</td></tr>
<tr class="memdesc:a644ab76d5f1dffea15710a549a80e378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> iff <code>other</code> points to the same node of the same tree. <br /></td></tr>
<tr class="separator:a644ab76d5f1dffea15710a549a80e378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce3fb428e8320ee1801b8ef9e5a12e7"><td class="memItemLeft" align="right" valign="top"><a id="a0ce3fb428e8320ee1801b8ef9e5a12e7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a0ce3fb428e8320ee1801b8ef9e5a12e7">operator!=</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;other) const</td></tr>
<tr class="memdesc:a0ce3fb428e8320ee1801b8ef9e5a12e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> iff <code>other</code> does not point to the same node of the same tree. <br /></td></tr>
<tr class="separator:a0ce3fb428e8320ee1801b8ef9e5a12e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab086ec1916db61d1ab56a801abca8d91"><td class="memItemLeft" align="right" valign="top"><a id="ab086ec1916db61d1ab56a801abca8d91"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a4f200ee652f18b2412fa000a8fedf794">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#ab086ec1916db61d1ab56a801abca8d91">operator*</a> () const</td></tr>
<tr class="memdesc:ab086ec1916db61d1ab56a801abca8d91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>*i</code>: Get the value of the current node <br /></td></tr>
<tr class="separator:ab086ec1916db61d1ab56a801abca8d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4e7d4e0fa56e9f7509c555f73d24d2"><td class="memItemLeft" align="right" valign="top"><a id="aef4e7d4e0fa56e9f7509c555f73d24d2"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a8fede1dd56a91627717fcbf0ef1bcb6e">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#aef4e7d4e0fa56e9f7509c555f73d24d2">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:aef4e7d4e0fa56e9f7509c555f73d24d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>i-&gt;...</code>: Access member of current node <br /></td></tr>
<tr class="separator:aef4e7d4e0fa56e9f7509c555f73d24d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65aa5dc1b8bfbc815ba7057c312ea154"><td class="memItemLeft" align="right" valign="top"><a id="a65aa5dc1b8bfbc815ba7057c312ea154"></a>
index_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a65aa5dc1b8bfbc815ba7057c312ea154">node_count</a> () const</td></tr>
<tr class="memdesc:a65aa5dc1b8bfbc815ba7057c312ea154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of direct child nodes. <br /></td></tr>
<tr class="separator:a65aa5dc1b8bfbc815ba7057c312ea154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460b83eeb68ebc31ef23757902fbccd0"><td class="memItemLeft" align="right" valign="top"><a id="a460b83eeb68ebc31ef23757902fbccd0"></a>
index_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a460b83eeb68ebc31ef23757902fbccd0">item_count</a> () const</td></tr>
<tr class="memdesc:a460b83eeb68ebc31ef23757902fbccd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of leaf items in this subtree. <br /></td></tr>
<tr class="separator:a460b83eeb68ebc31ef23757902fbccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefafb0a3345c2e3bf811fb14650a2943"><td class="memItemLeft" align="right" valign="top"><a id="aefafb0a3345c2e3bf811fb14650a2943"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#aefafb0a3345c2e3bf811fb14650a2943">begin</a> () const</td></tr>
<tr class="memdesc:aefafb0a3345c2e3bf811fb14650a2943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first child. <br /></td></tr>
<tr class="separator:aefafb0a3345c2e3bf811fb14650a2943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9e0a2b53534bc10d67ab581c1231bb"><td class="memItemLeft" align="right" valign="top"><a id="a3e9e0a2b53534bc10d67ab581c1231bb"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb">end</a> () const</td></tr>
<tr class="memdesc:a3e9e0a2b53534bc10d67ab581c1231bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last (off-end) child. <br /></td></tr>
<tr class="separator:a3e9e0a2b53534bc10d67ab581c1231bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15db153c8168cf7ca6534c32159459b7"><td class="memItemLeft" align="right" valign="top"><a id="a15db153c8168cf7ca6534c32159459b7"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a15db153c8168cf7ca6534c32159459b7">items_begin</a> () const</td></tr>
<tr class="memdesc:a15db153c8168cf7ca6534c32159459b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first object inside this subtree. <br /></td></tr>
<tr class="separator:a15db153c8168cf7ca6534c32159459b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1525bf78a2c1fe544c7ba1254adf643"><td class="memItemLeft" align="right" valign="top"><a id="ab1525bf78a2c1fe544c7ba1254adf643"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#ab1525bf78a2c1fe544c7ba1254adf643">items_end</a> () const</td></tr>
<tr class="memdesc:ab1525bf78a2c1fe544c7ba1254adf643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last (off-end) object in this subtree. It is invalid to increment or dereference this iterator. <br /></td></tr>
<tr class="separator:ab1525bf78a2c1fe544c7ba1254adf643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce68055059abc27305a4c0d8c80e485"><td class="memItemLeft" align="right" valign="top"><a id="a2ce68055059abc27305a4c0d8c80e485"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a2ce68055059abc27305a4c0d8c80e485">subtree_begin</a> () const</td></tr>
<tr class="memdesc:a2ce68055059abc27305a4c0d8c80e485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first subtree in a sequence covering all the nodes in this subtree, beginning with the first child of this node. <br /></td></tr>
<tr class="separator:a2ce68055059abc27305a4c0d8c80e485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4eca147d4c57d0c431fa440d8f98be"><td class="memItemLeft" align="right" valign="top"><a id="adf4eca147d4c57d0c431fa440d8f98be"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#adf4eca147d4c57d0c431fa440d8f98be">subtree_end</a> () const</td></tr>
<tr class="memdesc:adf4eca147d4c57d0c431fa440d8f98be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last (off-end) subtree in the sequence of all subtrees below this node. <br /></td></tr>
<tr class="separator:adf4eca147d4c57d0c431fa440d8f98be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201b9c6eefbceabdfd1820e04eac733a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a201b9c6eefbceabdfd1820e04eac733a">global_begin</a> () const</td></tr>
<tr class="memdesc:a201b9c6eefbceabdfd1820e04eac733a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first item in the entire tree (the global root).  <a href="#a201b9c6eefbceabdfd1820e04eac733a">More...</a><br /></td></tr>
<tr class="separator:a201b9c6eefbceabdfd1820e04eac733a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73c72f9f9beab6308a14be4a34b92c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#aa73c72f9f9beab6308a14be4a34b92c8">global_end</a> () const</td></tr>
<tr class="memdesc:aa73c72f9f9beab6308a14be4a34b92c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the last item in the entire tree (the global off-end node).  <a href="#aa73c72f9f9beab6308a14be4a34b92c8">More...</a><br /></td></tr>
<tr class="separator:aa73c72f9f9beab6308a14be4a34b92c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f1bd83e4929d36d71738d704d9e860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a42f1bd83e4929d36d71738d704d9e860">find_parent</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a3951804461d164a1dd2e7dd74721ff42">const_item_iterator</a> &amp;i) const</td></tr>
<tr class="memdesc:a42f1bd83e4929d36d71738d704d9e860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exhaustively search for the direct parent node of item <code>i</code> in this subtree.  <a href="#a42f1bd83e4929d36d71738d704d9e860">More...</a><br /></td></tr>
<tr class="separator:a42f1bd83e4929d36d71738d704d9e860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a04d0384e97e2e26d1fb2d4c0d40945"><td class="memTemplParams" colspan="2">template&lt;bool  BoundingFn&gt; </td></tr>
<tr class="memitem:a0a04d0384e97e2e26d1fb2d4c0d40945"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a0a04d0384e97e2e26d1fb2d4c0d40945">find_parent</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a3951804461d164a1dd2e7dd74721ff42">const_item_iterator</a> &amp;i) const</td></tr>
<tr class="memdesc:a0a04d0384e97e2e26d1fb2d4c0d40945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the direct parent node of item <code>i</code> in this subtree, using <code>BoundingFn</code> to exclude subtrees which cannot contain <code>i</code>.  <a href="#a0a04d0384e97e2e26d1fb2d4c0d40945">More...</a><br /></td></tr>
<tr class="separator:a0a04d0384e97e2e26d1fb2d4c0d40945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eae992e69b06cae3fac97c8190de068"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename BoundingFn , typename TestFn &gt; </td></tr>
<tr class="memitem:a4eae992e69b06cae3fac97c8190de068"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base_1_1_query_iterator.html">QueryIterator</a>&lt; <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>, Key, BoundingFn, TestFn &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a4eae992e69b06cae3fac97c8190de068">query</a> (const Key &amp;key, BoundingFn bound, TestFn test=<a class="el" href="classgeom_1_1_subtree_base.html#a91a30c04b434e85965c2de87da51da1e">visit_all_nodes</a>&lt; Key &gt;) const</td></tr>
<tr class="memdesc:a4eae992e69b06cae3fac97c8190de068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all the subtrees for which <code>test(*subtree, key)</code> returns true. The iterator dereferences to <code>self_t</code>.  <a href="#a4eae992e69b06cae3fac97c8190de068">More...</a><br /></td></tr>
<tr class="separator:a4eae992e69b06cae3fac97c8190de068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mutation functions</div></td></tr>
<tr class="memitem:ad43bcd0c6dc2c358fa5dffa45eba0784"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ad43bcd0c6dc2c358fa5dffa45eba0784"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ad43bcd0c6dc2c358fa5dffa45eba0784">insert_child_node</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;insert_before, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ad43bcd0c6dc2c358fa5dffa45eba0784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new tree node under this one, to the left of <code>insert_before</code>.  <a href="#ad43bcd0c6dc2c358fa5dffa45eba0784">More...</a><br /></td></tr>
<tr class="separator:ad43bcd0c6dc2c358fa5dffa45eba0784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa6141e19b8f2fd807db44f39bd0292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a9fa6141e19b8f2fd807db44f39bd0292">insert_child_node</a> (const NodeItem &amp;obj) const</td></tr>
<tr class="memdesc:a9fa6141e19b8f2fd807db44f39bd0292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to insert a new child node at the end of this node's children.  <a href="#a9fa6141e19b8f2fd807db44f39bd0292">More...</a><br /></td></tr>
<tr class="separator:a9fa6141e19b8f2fd807db44f39bd0292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e5b2197a9af6c7de917c272febf27c"><td class="memTemplParams" colspan="2">template&lt;typename NodeItemIterator &gt; </td></tr>
<tr class="memitem:ad9e5b2197a9af6c7de917c272febf27c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ad9e5b2197a9af6c7de917c272febf27c">insert_child_nodes</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;insert_before, NodeItemIterator i_begin, const NodeItemIterator &amp;i_end) const</td></tr>
<tr class="memdesc:ad9e5b2197a9af6c7de917c272febf27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new tree nodes to the left of <code>insert_before</code>, under this node. Return the first newly created node.  <a href="#ad9e5b2197a9af6c7de917c272febf27c">More...</a><br /></td></tr>
<tr class="separator:ad9e5b2197a9af6c7de917c272febf27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8542de77c45cb39797787a9161b9e70"><td class="memTemplParams" colspan="2"><a id="ab8542de77c45cb39797787a9161b9e70"></a>
template&lt;typename NodeItemIterator &gt; </td></tr>
<tr class="memitem:ab8542de77c45cb39797787a9161b9e70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ab8542de77c45cb39797787a9161b9e70">insert_child_nodes</a> (const NodeItemIterator &amp;i_begin, const NodeItemIterator &amp;i_end) const</td></tr>
<tr class="memdesc:ab8542de77c45cb39797787a9161b9e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to insert multiple new child nodes at the end of this node's children. <br /></td></tr>
<tr class="separator:ab8542de77c45cb39797787a9161b9e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e87236526322b0d94e9b9bffaacf4ae"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a3e87236526322b0d94e9b9bffaacf4ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a3e87236526322b0d94e9b9bffaacf4ae">insert_item</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;insert_before, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a3e87236526322b0d94e9b9bffaacf4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an item under this node.  <a href="#a3e87236526322b0d94e9b9bffaacf4ae">More...</a><br /></td></tr>
<tr class="separator:a3e87236526322b0d94e9b9bffaacf4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aaf41ae8bd4001ebc19f11838f7f18f"><td class="memItemLeft" align="right" valign="top"><a id="a2aaf41ae8bd4001ebc19f11838f7f18f"></a>
<a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a2aaf41ae8bd4001ebc19f11838f7f18f">insert_item</a> (const LeafItem &amp;item) const</td></tr>
<tr class="memdesc:a2aaf41ae8bd4001ebc19f11838f7f18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to insert a new item at the end. <br /></td></tr>
<tr class="separator:a2aaf41ae8bd4001ebc19f11838f7f18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd47cfabcde9c76cfb713ad49ea8dbeb"><td class="memTemplParams" colspan="2">template&lt;typename LeafItemIterator &gt; </td></tr>
<tr class="memitem:acd47cfabcde9c76cfb713ad49ea8dbeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#acd47cfabcde9c76cfb713ad49ea8dbeb">insert_items</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;insert_before, const LeafItemIterator begin_item, const LeafItemIterator &amp;end_item, index_t *new_item_count=nullptr) const</td></tr>
<tr class="memdesc:acd47cfabcde9c76cfb713ad49ea8dbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert multiple leaf items into this node.  <a href="#acd47cfabcde9c76cfb713ad49ea8dbeb">More...</a><br /></td></tr>
<tr class="separator:acd47cfabcde9c76cfb713ad49ea8dbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df12374d1e643483e5ee23bc1091f0a"><td class="memTemplParams" colspan="2"><a id="a9df12374d1e643483e5ee23bc1091f0a"></a>
template&lt;typename LeafItemIterator &gt; </td></tr>
<tr class="memitem:a9df12374d1e643483e5ee23bc1091f0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a9df12374d1e643483e5ee23bc1091f0a">insert_items</a> (const LeafItemIterator &amp;begin_item, const LeafItemIterator &amp;end_item) const</td></tr>
<tr class="memdesc:a9df12374d1e643483e5ee23bc1091f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to insert multiple new items at the end of this node's item list. <br /></td></tr>
<tr class="separator:a9df12374d1e643483e5ee23bc1091f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae049a89eb287b5619e422553f54c9e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ae049a89eb287b5619e422553f54c9e9f">adopt</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a6cd58c336bc87a751dc6be5b23328231">const_iterator</a> &amp;other_subtree, const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;insert_before) const</td></tr>
<tr class="memdesc:ae049a89eb287b5619e422553f54c9e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of <code>other_subtree</code> and insert it as a child of this node immediately before <code>insert_before</code>.  <a href="#ae049a89eb287b5619e422553f54c9e9f">More...</a><br /></td></tr>
<tr class="separator:ae049a89eb287b5619e422553f54c9e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d86fc897b16f394375e92efbe5c873b"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename P , typename ... Args&gt; </td></tr>
<tr class="memitem:a8d86fc897b16f394375e92efbe5c873b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a8d86fc897b16f394375e92efbe5c873b">split</a> (Func compare, P pivot, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a8d86fc897b16f394375e92efbe5c873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split this node into two sibling nodes.  <a href="#a8d86fc897b16f394375e92efbe5c873b">More...</a><br /></td></tr>
<tr class="separator:a8d86fc897b16f394375e92efbe5c873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43148e9c5506596f5ad5bbe96ab7d8cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a43148e9c5506596f5ad5bbe96ab7d8cd">erase</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;item, bool *success=nullptr) const</td></tr>
<tr class="memdesc:a43148e9c5506596f5ad5bbe96ab7d8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from this subtree.  <a href="#a43148e9c5506596f5ad5bbe96ab7d8cd">More...</a><br /></td></tr>
<tr class="separator:a43148e9c5506596f5ad5bbe96ab7d8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1d9633e64d0de6a36e0af17ccd8163"><td class="memItemLeft" align="right" valign="top"><a id="adf1d9633e64d0de6a36e0af17ccd8163"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#adf1d9633e64d0de6a36e0af17ccd8163">clear</a> () const</td></tr>
<tr class="memdesc:adf1d9633e64d0de6a36e0af17ccd8163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty this node of all child nodes and descendent items. <br /></td></tr>
<tr class="separator:adf1d9633e64d0de6a36e0af17ccd8163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63697b53c775f64d0cfe962e0ad1b8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a63697b53c775f64d0cfe962e0ad1b8c6">erase</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;child, bool *success=nullptr) const</td></tr>
<tr class="memdesc:a63697b53c775f64d0cfe962e0ad1b8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the subtree and its root at <code>child</code>, including all its leaf items.  <a href="#a63697b53c775f64d0cfe962e0ad1b8c6">More...</a><br /></td></tr>
<tr class="separator:a63697b53c775f64d0cfe962e0ad1b8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada96bbb426ada24e24e6960972f3cdaf"><td class="memItemLeft" align="right" valign="top"><a id="ada96bbb426ada24e24e6960972f3cdaf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ada96bbb426ada24e24e6960972f3cdaf">flatten</a> () const</td></tr>
<tr class="memdesc:ada96bbb426ada24e24e6960972f3cdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively remove all the children of this node, and take ownership of all items beneath them. <br /></td></tr>
<tr class="separator:ada96bbb426ada24e24e6960972f3cdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a91a30c04b434e85965c2de87da51da1e"><td class="memTemplParams" colspan="2"><a id="a91a30c04b434e85965c2de87da51da1e"></a>
template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a91a30c04b434e85965c2de87da51da1e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#a91a30c04b434e85965c2de87da51da1e">visit_all_nodes</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;s, const Key &amp;k)</td></tr>
<tr class="memdesc:a91a30c04b434e85965c2de87da51da1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience test function for <code><a class="el" href="classgeom_1_1_subtree_base.html#a4eae992e69b06cae3fac97c8190de068" title="Return an iterator over all the subtrees for which test(*subtree, key) returns true. The iterator dereferences to self_t. ">query()</a></code> which returns <code>true</code> on all nodes. <br /></td></tr>
<tr class="separator:a91a30c04b434e85965c2de87da51da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b5378b3df842051b627d640ca0a75e"><td class="memTemplParams" colspan="2"><a id="af3b5378b3df842051b627d640ca0a75e"></a>
template&lt;typename Key &gt; </td></tr>
<tr class="memitem:af3b5378b3df842051b627d640ca0a75e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree_base.html#af3b5378b3df842051b627d640ca0a75e">visit_all_leaf_nodes</a> (const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;s, const Key &amp;k)</td></tr>
<tr class="memdesc:af3b5378b3df842051b627d640ca0a75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience test function for <code><a class="el" href="classgeom_1_1_subtree_base.html#a4eae992e69b06cae3fac97c8190de068" title="Return an iterator over all the subtrees for which test(*subtree, key) returns true. The iterator dereferences to self_t. ">query()</a></code> which returns <code>true</code> on all nodes with zero child nodes. <br /></td></tr>
<tr class="separator:af3b5378b3df842051b627d640ca0a75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename NodeItem, typename LeafItem&gt;<br />
class geom::Subtree&lt; NodeItem, LeafItem &gt;</h3>

<p>A non-const iterator to a subtree. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae049a89eb287b5619e422553f54c9e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae049a89eb287b5619e422553f54c9e9f">&#9670;&nbsp;</a></span>adopt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> adopt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a6cd58c336bc87a751dc6be5b23328231">const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other_subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of <code>other_subtree</code> and insert it as a child of this node immediately before <code>insert_before</code>. </p>
<p>If <code>insert_before</code> is not a child or end-child of this node, the tree is unchanged and <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> is returned.</p>
<p>Invalidates all <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> subtrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_subtree</td><td>The subtree to copy and adopt as a child. </td></tr>
    <tr><td class="paramname">insert_before</td><td>The child of this node before which to insert the new subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing at the root of the new adopted subtree. </dd></dl>

</div>
</div>
<a id="a43148e9c5506596f5ad5bbe96ab7d8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43148e9c5506596f5ad5bbe96ab7d8cd">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an item from this subtree. </p>
<p>If <code>item</code> is not in the subtree, or if this subtree is not a leaf node, the tree will be unchanged.</p>
<p>Invalidates the iterator to this item, and potentially any <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> <code>item_iterator</code>s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to delete; a direct child of this node. </td></tr>
    <tr><td class="paramname">success</td><td>Optional return value pointer to be filled with <code>true</code> if the item was deleted; <code>false</code> if the tree is unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the position of the item just beyond the one that was deleted. This will be <code><a class="el" href="classgeom_1_1_subtree_base.html#ab1525bf78a2c1fe544c7ba1254adf643" title="Get last (off-end) object in this subtree. It is invalid to increment or dereference this iterator...">items_end()</a></code> if the deleted item was the last one in its parent node. </dd></dl>

</div>
</div>
<a id="a63697b53c775f64d0cfe962e0ad1b8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63697b53c775f64d0cfe962e0ad1b8c6">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the subtree and its root at <code>child</code>, including all its leaf items. </p>
<p>If <code>child</code> is not a direct child of this node, the tree is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>An optional return value pointer; to be filled with <code>true</code> if the child was deleted; <code>false</code> if the tree is unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the position of the node following the deleted one (which may be <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code>). </dd></dl>

</div>
</div>
<a id="a42f1bd83e4929d36d71738d704d9e860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f1bd83e4929d36d71738d704d9e860">&#9670;&nbsp;</a></span>find_parent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> find_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a3951804461d164a1dd2e7dd74721ff42">const_item_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exhaustively search for the direct parent node of item <code>i</code> in this subtree. </p>
<p>If <code>i</code> is not in the subtree under this node, then return <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code>. </p>

</div>
</div>
<a id="a0a04d0384e97e2e26d1fb2d4c0d40945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a04d0384e97e2e26d1fb2d4c0d40945">&#9670;&nbsp;</a></span>find_parent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> find_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a3951804461d164a1dd2e7dd74721ff42">const_item_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the direct parent node of item <code>i</code> in this subtree, using <code>BoundingFn</code> to exclude subtrees which cannot contain <code>i</code>. </p>
<p>If <code>i</code> is not in the subtree under this node, then return <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code>.</p>
<p>Because <code>BoundingFn</code> is templated, it may be inlined for performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The item to find the parent of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BoundingFn</td><td>A function which returns <code>true</code> if node <code>n</code> might possibly contain item <code>i</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a201b9c6eefbceabdfd1820e04eac733a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201b9c6eefbceabdfd1820e04eac733a">&#9670;&nbsp;</a></span>global_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> global_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first item in the entire tree (the global root). </p>
<p>Alias for <code>this-&gt;<a class="el" href="classgeom_1_1_subtree_base.html#a591440a4ec3be574e382eae31e0589b5" title="Obtain the tree into which this iterator points. ">tree()</a>.<a class="el" href="classgeom_1_1_subtree_base.html#aefafb0a3345c2e3bf811fb14650a2943" title="Get first child. ">begin()</a></code>. </p>

</div>
</div>
<a id="aa73c72f9f9beab6308a14be4a34b92c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73c72f9f9beab6308a14be4a34b92c8">&#9670;&nbsp;</a></span>global_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> global_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the last item in the entire tree (the global off-end node). </p>
<p>Alias for <code>this-&gt;<a class="el" href="classgeom_1_1_subtree_base.html#a591440a4ec3be574e382eae31e0589b5" title="Obtain the tree into which this iterator points. ">tree()</a>.<a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code>. </p>

</div>
</div>
<a id="ad43bcd0c6dc2c358fa5dffa45eba0784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43bcd0c6dc2c358fa5dffa45eba0784">&#9670;&nbsp;</a></span>insert_child_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> insert_child_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new tree node under this one, to the left of <code>insert_before</code>. </p>
<p>If this node was previously empty, then its new first child will contain all of its <code>LeafItem</code>s (this is to ensure those leaf items all have a parent which is a leaf node). Otherwise, the new node will be empty of any <code>LeafItem</code>s.</p>
<p>If <code>insert_before</code> is the root node, or if <code>insert_before</code> is not a direct child (or end-child) of this node, then the tree is unaffected and <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> is returned. Otherwise, the new node is returned.</p>
<p>Potentially invalidates the <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> of other subtrees, or the <code><a class="el" href="classgeom_1_1_subtree_base.html#aefafb0a3345c2e3bf811fb14650a2943" title="Get first child. ">begin()</a></code> of this subtree if <code>insert_before</code> is <code><a class="el" href="classgeom_1_1_subtree_base.html#aefafb0a3345c2e3bf811fb14650a2943" title="Get first child. ">begin()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_before</td><td>A subtree pointing to a child or end-child of this node. </td></tr>
    <tr><td class="paramname">args</td><td>Construction arguments for the new <code>NodeItem</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created node, or <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> if the node could not be created. </dd></dl>

</div>
</div>
<a id="a9fa6141e19b8f2fd807db44f39bd0292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa6141e19b8f2fd807db44f39bd0292">&#9670;&nbsp;</a></span>insert_child_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> insert_child_node </td>
          <td>(</td>
          <td class="paramtype">const NodeItem &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to insert a new child node at the end of this node's children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>NodeItem to insert into the new node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9e5b2197a9af6c7de917c272febf27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e5b2197a9af6c7de917c272febf27c">&#9670;&nbsp;</a></span>insert_child_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> insert_child_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeItemIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeItemIterator &amp;&#160;</td>
          <td class="paramname"><em>i_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new tree nodes to the left of <code>insert_before</code>, under this node. Return the first newly created node. </p>
<p>If this node was previously empty, then its new first child will contain all its <code>LeafItem</code>s (this is to ensure those leaf items all have a parent which is a leaf node). All other new nodes will be empty of any <code>LeafItem</code>s.</p>
<p>If <code>insert_before</code> is the root node, or if <code>insert_before</code> is not a child (or end-child) of this node, then the tree is unaffected and <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> is returned. Likewise, if no new nodes were inserted, <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> is returned. Otherwise, the first new node is returned.</p>
<p>Potentially invalidates the <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> of other subtrees, or the <code><a class="el" href="classgeom_1_1_subtree_base.html#aefafb0a3345c2e3bf811fb14650a2943" title="Get first child. ">begin()</a></code> of this subtree if <code>insert_before</code> is <code><a class="el" href="classgeom_1_1_subtree_base.html#aefafb0a3345c2e3bf811fb14650a2943" title="Get first child. ">begin()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_before</td><td>A <a class="el" href="classgeom_1_1_subtree.html" title="A non-const iterator to a subtree. ">Subtree</a> pointing to the sibling just after the last new node to be inserted. </td></tr>
    <tr><td class="paramname">i_begin</td><td>A forward iterator to the first NodeItem to be inserted. </td></tr>
    <tr><td class="paramname">i_end</td><td>A forward iterator just beyond the last NodeItem to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first newly created node, or <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> if no new nodes were created. </dd></dl>

</div>
</div>
<a id="a3e87236526322b0d94e9b9bffaacf4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e87236526322b0d94e9b9bffaacf4ae">&#9670;&nbsp;</a></span>insert_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> insert_item </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an item under this node. </p>
<p>The new item will be inserted before the item at <code>insert_before</code>, which must belong to this node, otherwise the behavior is undefined. It is permissible for <code>insert_before</code> to be this node's <code><a class="el" href="classgeom_1_1_subtree_base.html#a15db153c8168cf7ca6534c32159459b7" title="Get first object inside this subtree. ">items_begin()</a></code> or <code><a class="el" href="classgeom_1_1_subtree_base.html#ab1525bf78a2c1fe544c7ba1254adf643" title="Get last (off-end) object in this subtree. It is invalid to increment or dereference this iterator...">items_end()</a></code>.</p>
<p>This must be a leaf node; i.e. one with no child nodes, so that placement of the new objects is not abiguous. If this is not a leaf node, the tree is unchanged.</p>
<p>Potentially invalidates the <code><a class="el" href="classgeom_1_1_subtree_base.html#ab1525bf78a2c1fe544c7ba1254adf643" title="Get last (off-end) object in this subtree. It is invalid to increment or dereference this iterator...">items_end()</a></code> of other subtrees, or the <code><a class="el" href="classgeom_1_1_subtree_base.html#a15db153c8168cf7ca6534c32159459b7" title="Get first object inside this subtree. ">items_begin()</a></code> of this subtree if <code>insert_before</code> is <code><a class="el" href="classgeom_1_1_subtree_base.html#a15db153c8168cf7ca6534c32159459b7" title="Get first object inside this subtree. ">items_begin()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_before</td><td>Item belonging to <code>parent</code> which the new items are to be inserted before. </td></tr>
    <tr><td class="paramname">args</td><td>New <code>LeafItem</code> to be inserted, or constructor arguments for the new <code>LeafItem</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first newly placed item if any were placed; <code><a class="el" href="classgeom_1_1_subtree_base.html#ab1525bf78a2c1fe544c7ba1254adf643" title="Get last (off-end) object in this subtree. It is invalid to increment or dereference this iterator...">items_end()</a></code> otherwise. </dd></dl>

</div>
</div>
<a id="acd47cfabcde9c76cfb713ad49ea8dbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd47cfabcde9c76cfb713ad49ea8dbeb">&#9670;&nbsp;</a></span>insert_items()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> insert_items </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree_base.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LeafItemIterator&#160;</td>
          <td class="paramname"><em>begin_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LeafItemIterator &amp;&#160;</td>
          <td class="paramname"><em>end_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t *&#160;</td>
          <td class="paramname"><em>new_item_count</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert multiple leaf items into this node. </p>
<p>The new items will be inserted before the item at <code>insert_before</code>, in the same order. <code>insert_before</code> must belong to the given node, otherwise the behavior is undefined. It is permissible for <code>insert_before</code> to be the node's <code><a class="el" href="classgeom_1_1_subtree_base.html#a15db153c8168cf7ca6534c32159459b7" title="Get first object inside this subtree. ">items_begin()</a></code> or <code><a class="el" href="classgeom_1_1_subtree_base.html#ab1525bf78a2c1fe544c7ba1254adf643" title="Get last (off-end) object in this subtree. It is invalid to increment or dereference this iterator...">items_end()</a></code>.</p>
<p>This must be a leaf node; i.e. one with no child nodes, so that placement of the new objects is not abiguous. If this is not a leaf node, the tree is unchanged.</p>
<p>Invalidates all <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> <code>item_iterator</code>s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Leaf node under which the new items will be inserted. </td></tr>
    <tr><td class="paramname">insert_before</td><td>Item belonging to <code>parent</code> which the new items are to be inserted before. </td></tr>
    <tr><td class="paramname">first_item</td><td>Forward iterator to first <code>LeafItem</code> to be inserted. </td></tr>
    <tr><td class="paramname">off_end_item</td><td>Forward iterator just beyond the last <code>LeafItem</code> to be inserted. </td></tr>
    <tr><td class="paramname">new_item_count</td><td>Optional return pointer to receive the count of newly placed objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first newly placed item if any were placed; <code><a class="el" href="classgeom_1_1_subtree_base.html#ab1525bf78a2c1fe544c7ba1254adf643" title="Get last (off-end) object in this subtree. It is invalid to increment or dereference this iterator...">items_end()</a></code> otherwise. </dd></dl>

</div>
</div>
<a id="a85dd8856ad445b1f8170d98309e63b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dd8856ad445b1f8170d98309e63b50">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parent node. </p>
<p>The parent of <code><a class="el" href="classgeom_1_1_subtree_base.html#a591440a4ec3be574e382eae31e0589b5" title="Obtain the tree into which this iterator points. ">tree()</a>-&gt;root()</code> is <code><a class="el" href="classgeom_1_1_subtree_base.html#a591440a4ec3be574e382eae31e0589b5" title="Obtain the tree into which this iterator points. ">tree()</a>-&gt;<a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code>. </p>

</div>
</div>
<a id="a4eae992e69b06cae3fac97c8190de068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eae992e69b06cae3fac97c8190de068">&#9670;&nbsp;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base_1_1_query_iterator.html">QueryIterator</a>&lt;<a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a>, Key, BoundingFn, TestFn&gt; query </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundingFn&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TestFn&#160;</td>
          <td class="paramname"><em>test</em> = <code><a class="el" href="classgeom_1_1_subtree_base.html#a91a30c04b434e85965c2de87da51da1e">visit_all_nodes</a>&lt;Key&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all the subtrees for which <code>test(*subtree, key)</code> returns true. The iterator dereferences to <code>self_t</code>. </p>
<p>The iterator's sequence finishes on this node's <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> node. (<code>QueryIterator</code>s and <code><a class="el" href="classgeom_1_1_subtree.html" title="A non-const iterator to a subtree. ">Subtree</a></code> nodes can be compared directly).</p>
<p><code><a class="el" href="classgeom_1_1_subtree_base.html#a91a30c04b434e85965c2de87da51da1e" title="Convenience test function for query() which returns true on all nodes. ">visit_all_nodes()</a></code> and <code><a class="el" href="classgeom_1_1_subtree_base.html#af3b5378b3df842051b627d640ca0a75e" title="Convenience test function for query() which returns true on all nodes with zero child nodes...">visit_all_leaf_nodes()</a></code> are convenience static member functions of this class which can be passed to <code>test()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound</td><td>A callable object which accepts a <a class="el" href="classgeom_1_1_subtree.html" title="A non-const iterator to a subtree. ">Subtree</a> as its first argument, and a <code>Key</code> as its second, and returns <code>true</code> if that <a class="el" href="classgeom_1_1_subtree.html" title="A non-const iterator to a subtree. ">Subtree</a> might contain objects which pass <code>test()</code> for that key. Children of Subtrees which do not pass <code>bound()</code> will be skipped. </td></tr>
    <tr><td class="paramname">test</td><td>A callable object which accepts a <a class="el" href="classgeom_1_1_subtree.html" title="A non-const iterator to a subtree. ">Subtree</a> as its first argument and a <code>Key</code> as its second, and returns <code>true</code> if that <a class="el" href="classgeom_1_1_subtree.html" title="A non-const iterator to a subtree. ">Subtree</a> should be visited by the iterator. If omitted, all nodes which pass <code>bound()</code> will be visited. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d86fc897b16f394375e92efbe5c873b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d86fc897b16f394375e92efbe5c873b">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree_base.html#a20332cb6a90a1f49b19c1f5795a8b11f">self_t</a> split </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split this node into two sibling nodes. </p>
<p>A new node will be created just before this one, under the same parent, and this node's items will be split between them according to the result of <code>compare(item, pivot)</code>: If the comparison is less than zero, the item will be moved to the left (new) node. Otherwise, it will remain in the right (existing) node.</p>
<p>The split node must not be the root, must have no children, and must contain at least two items. If any of these is the case, the tree will not be changed and the off-end node will be returned.</p>
<p>All iterators to the items under this node are invalidated by this operation, as well as potentially any <code><a class="el" href="classgeom_1_1_subtree_base.html#a3e9e0a2b53534bc10d67ab581c1231bb" title="Get last (off-end) child. ">end()</a></code> <code>item_iterator</code>s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>A callable object <code>compare(a,b)</code> which accepts a <code>LeafItem</code> as its left argument and a <code>P</code> as its right argument, and returns a signed number (negative for <code>a &lt; b</code>, positive for <code>a &gt; b</code>, zero for equality). </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments for the <code>NodeItem</code> object to be assigned to the newly-created (low) node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created sibling, or the off-end node if this is the root node or has child nodes. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>geomc/<a class="el" href="_tree_8h_source.html">Tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 2 2018 01:15:18 for geomc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
