<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geomc: Subtree&lt; NodeItem, LeafItem &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">geomc
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A c++ linear algebra template library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeom.html">geom</a></li><li class="navelem"><a class="el" href="classgeom_1_1_subtree.html">Subtree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgeom_1_1_subtree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Subtree&lt; NodeItem, LeafItem &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__storage.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A non-const iterator to a subtree.  
 <a href="classgeom_1_1_subtree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_tree_8h_source.html">geomc/Tree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7c32a864c1c2ee5ef60d3e5eeff7aa8f"><td class="memItemLeft" align="right" valign="top"><a id="a7c32a864c1c2ee5ef60d3e5eeff7aa8f"></a>
typedef <a class="el" href="classgeom_1_1_subtree.html">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a7c32a864c1c2ee5ef60d3e5eeff7aa8f">iterator</a></td></tr>
<tr class="memdesc:a7c32a864c1c2ee5ef60d3e5eeff7aa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (possibly const) iterator over subtrees. <br /></td></tr>
<tr class="separator:a7c32a864c1c2ee5ef60d3e5eeff7aa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd58c336bc87a751dc6be5b23328231"><td class="memItemLeft" align="right" valign="top"><a id="a6cd58c336bc87a751dc6be5b23328231"></a>
typedef <a class="el" href="classgeom_1_1_const_subtree.html">ConstSubtree</a>&lt; NodeItem, LeafItem &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a6cd58c336bc87a751dc6be5b23328231">const_iterator</a></td></tr>
<tr class="memdesc:a6cd58c336bc87a751dc6be5b23328231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over subtrees. <br /></td></tr>
<tr class="separator:a6cd58c336bc87a751dc6be5b23328231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f4b7955d1888fe47dbc9e682456ac5"><td class="memItemLeft" align="right" valign="top"><a id="a75f4b7955d1888fe47dbc9e682456ac5"></a>
typedef std::conditional&lt; Const, ConstItemRef, ItemRef &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a></td></tr>
<tr class="memdesc:a75f4b7955d1888fe47dbc9e682456ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (possibly const) iterator to <code>LeafItem</code>s. <br /></td></tr>
<tr class="separator:a75f4b7955d1888fe47dbc9e682456ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27fbff87cc12f43330d1b4c48e93b0bd"><td class="memItemLeft" align="right" valign="top"><a id="a27fbff87cc12f43330d1b4c48e93b0bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a27fbff87cc12f43330d1b4c48e93b0bd">Subtree</a> (const <a class="el" href="classgeom_1_1_subtree.html">Subtree</a>&lt; NodeItem, LeafItem &gt; &amp;other)=default</td></tr>
<tr class="memdesc:a27fbff87cc12f43330d1b4c48e93b0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a duplicate iterator to the same node of the same tree. <br /></td></tr>
<tr class="separator:a27fbff87cc12f43330d1b4c48e93b0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mutation functions</div></td></tr>
<tr class="memitem:ad43bcd0c6dc2c358fa5dffa45eba0784"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ad43bcd0c6dc2c358fa5dffa45eba0784"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html">self_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ad43bcd0c6dc2c358fa5dffa45eba0784">insert_child_node</a> (const <a class="el" href="classgeom_1_1_subtree.html">self_t</a> &amp;insert_before, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ad43bcd0c6dc2c358fa5dffa45eba0784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new tree node under this one, to the left of <code>insert_before</code>.  <a href="classgeom_1_1_subtree.html#ad43bcd0c6dc2c358fa5dffa45eba0784">More...</a><br /></td></tr>
<tr class="separator:ad43bcd0c6dc2c358fa5dffa45eba0784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa6141e19b8f2fd807db44f39bd0292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a9fa6141e19b8f2fd807db44f39bd0292">insert_child_node</a> (const NodeItem &amp;obj) const</td></tr>
<tr class="memdesc:a9fa6141e19b8f2fd807db44f39bd0292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to insert a new child node at the end of this node's children.  <a href="classgeom_1_1_subtree.html#a9fa6141e19b8f2fd807db44f39bd0292">More...</a><br /></td></tr>
<tr class="separator:a9fa6141e19b8f2fd807db44f39bd0292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e5b2197a9af6c7de917c272febf27c"><td class="memTemplParams" colspan="2">template&lt;typename NodeItemIterator &gt; </td></tr>
<tr class="memitem:ad9e5b2197a9af6c7de917c272febf27c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html">self_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ad9e5b2197a9af6c7de917c272febf27c">insert_child_nodes</a> (const <a class="el" href="classgeom_1_1_subtree.html">self_t</a> &amp;insert_before, NodeItemIterator i_begin, const NodeItemIterator &amp;i_end) const</td></tr>
<tr class="memdesc:ad9e5b2197a9af6c7de917c272febf27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new tree nodes to the left of <code>insert_before</code>, under this node. Return the first newly created node.  <a href="classgeom_1_1_subtree.html#ad9e5b2197a9af6c7de917c272febf27c">More...</a><br /></td></tr>
<tr class="separator:ad9e5b2197a9af6c7de917c272febf27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8542de77c45cb39797787a9161b9e70"><td class="memTemplParams" colspan="2"><a id="ab8542de77c45cb39797787a9161b9e70"></a>
template&lt;typename NodeItemIterator &gt; </td></tr>
<tr class="memitem:ab8542de77c45cb39797787a9161b9e70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html">self_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ab8542de77c45cb39797787a9161b9e70">insert_child_nodes</a> (const NodeItemIterator &amp;i_begin, const NodeItemIterator &amp;i_end) const</td></tr>
<tr class="memdesc:ab8542de77c45cb39797787a9161b9e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to insert multiple new child nodes at the end of this node's children. <br /></td></tr>
<tr class="separator:ab8542de77c45cb39797787a9161b9e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e87236526322b0d94e9b9bffaacf4ae"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a3e87236526322b0d94e9b9bffaacf4ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a3e87236526322b0d94e9b9bffaacf4ae">insert_item</a> (const <a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;insert_before, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a3e87236526322b0d94e9b9bffaacf4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an item under this node.  <a href="classgeom_1_1_subtree.html#a3e87236526322b0d94e9b9bffaacf4ae">More...</a><br /></td></tr>
<tr class="separator:a3e87236526322b0d94e9b9bffaacf4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aaf41ae8bd4001ebc19f11838f7f18f"><td class="memItemLeft" align="right" valign="top"><a id="a2aaf41ae8bd4001ebc19f11838f7f18f"></a>
<a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a2aaf41ae8bd4001ebc19f11838f7f18f">insert_item</a> (const LeafItem &amp;item) const</td></tr>
<tr class="memdesc:a2aaf41ae8bd4001ebc19f11838f7f18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to insert a new item at the end. <br /></td></tr>
<tr class="separator:a2aaf41ae8bd4001ebc19f11838f7f18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd47cfabcde9c76cfb713ad49ea8dbeb"><td class="memTemplParams" colspan="2">template&lt;typename LeafItemIterator &gt; </td></tr>
<tr class="memitem:acd47cfabcde9c76cfb713ad49ea8dbeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#acd47cfabcde9c76cfb713ad49ea8dbeb">insert_items</a> (const <a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;insert_before, const LeafItemIterator begin_item, const LeafItemIterator &amp;end_item, index_t *new_item_count=nullptr) const</td></tr>
<tr class="memdesc:acd47cfabcde9c76cfb713ad49ea8dbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert multiple leaf items into this node.  <a href="classgeom_1_1_subtree.html#acd47cfabcde9c76cfb713ad49ea8dbeb">More...</a><br /></td></tr>
<tr class="separator:acd47cfabcde9c76cfb713ad49ea8dbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df12374d1e643483e5ee23bc1091f0a"><td class="memTemplParams" colspan="2"><a id="a9df12374d1e643483e5ee23bc1091f0a"></a>
template&lt;typename LeafItemIterator &gt; </td></tr>
<tr class="memitem:a9df12374d1e643483e5ee23bc1091f0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a9df12374d1e643483e5ee23bc1091f0a">insert_items</a> (const LeafItemIterator &amp;begin_item, const LeafItemIterator &amp;end_item) const</td></tr>
<tr class="memdesc:a9df12374d1e643483e5ee23bc1091f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to insert multiple new items at the end of this node's item list. <br /></td></tr>
<tr class="separator:a9df12374d1e643483e5ee23bc1091f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae049a89eb287b5619e422553f54c9e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ae049a89eb287b5619e422553f54c9e9f">adopt</a> (const <a class="el" href="classgeom_1_1_subtree.html#a6cd58c336bc87a751dc6be5b23328231">const_iterator</a> &amp;other_subtree, const <a class="el" href="classgeom_1_1_subtree.html">self_t</a> &amp;insert_before) const</td></tr>
<tr class="memdesc:ae049a89eb287b5619e422553f54c9e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of <code>other_subtree</code> and insert it as a child of this node immediately before <code>insert_before</code>.  <a href="classgeom_1_1_subtree.html#ae049a89eb287b5619e422553f54c9e9f">More...</a><br /></td></tr>
<tr class="separator:ae049a89eb287b5619e422553f54c9e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d86fc897b16f394375e92efbe5c873b"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename P , typename ... Args&gt; </td></tr>
<tr class="memitem:a8d86fc897b16f394375e92efbe5c873b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html">self_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a8d86fc897b16f394375e92efbe5c873b">split</a> (Func compare, P pivot, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a8d86fc897b16f394375e92efbe5c873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split this node into two sibling nodes.  <a href="classgeom_1_1_subtree.html#a8d86fc897b16f394375e92efbe5c873b">More...</a><br /></td></tr>
<tr class="separator:a8d86fc897b16f394375e92efbe5c873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43148e9c5506596f5ad5bbe96ab7d8cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a43148e9c5506596f5ad5bbe96ab7d8cd">erase</a> (const <a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;item, bool *success=nullptr) const</td></tr>
<tr class="memdesc:a43148e9c5506596f5ad5bbe96ab7d8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from this subtree.  <a href="classgeom_1_1_subtree.html#a43148e9c5506596f5ad5bbe96ab7d8cd">More...</a><br /></td></tr>
<tr class="separator:a43148e9c5506596f5ad5bbe96ab7d8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1d9633e64d0de6a36e0af17ccd8163"><td class="memItemLeft" align="right" valign="top"><a id="adf1d9633e64d0de6a36e0af17ccd8163"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#adf1d9633e64d0de6a36e0af17ccd8163">clear</a> () const</td></tr>
<tr class="memdesc:adf1d9633e64d0de6a36e0af17ccd8163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty this node of all child nodes and descendent items. <br /></td></tr>
<tr class="separator:adf1d9633e64d0de6a36e0af17ccd8163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63697b53c775f64d0cfe962e0ad1b8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_subtree.html">self_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#a63697b53c775f64d0cfe962e0ad1b8c6">erase</a> (const <a class="el" href="classgeom_1_1_subtree.html">self_t</a> &amp;child, bool *success=nullptr) const</td></tr>
<tr class="memdesc:a63697b53c775f64d0cfe962e0ad1b8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the subtree and its root at <code>child</code>, including all its leaf items.  <a href="classgeom_1_1_subtree.html#a63697b53c775f64d0cfe962e0ad1b8c6">More...</a><br /></td></tr>
<tr class="separator:a63697b53c775f64d0cfe962e0ad1b8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada96bbb426ada24e24e6960972f3cdaf"><td class="memItemLeft" align="right" valign="top"><a id="ada96bbb426ada24e24e6960972f3cdaf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_subtree.html#ada96bbb426ada24e24e6960972f3cdaf">flatten</a> () const</td></tr>
<tr class="memdesc:ada96bbb426ada24e24e6960972f3cdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively remove all the children of this node, and take ownership of all items beneath them. <br /></td></tr>
<tr class="separator:ada96bbb426ada24e24e6960972f3cdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename NodeItem, typename LeafItem&gt;<br />
class geom::Subtree&lt; NodeItem, LeafItem &gt;</h3>

<p>A non-const iterator to a subtree. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae049a89eb287b5619e422553f54c9e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae049a89eb287b5619e422553f54c9e9f">&#9670;&nbsp;</a></span>adopt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree.html">self_t</a> adopt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree.html#a6cd58c336bc87a751dc6be5b23328231">const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other_subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree.html">self_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of <code>other_subtree</code> and insert it as a child of this node immediately before <code>insert_before</code>. </p>
<p>If <code>insert_before</code> is not a child or end-child of this node, the tree is unchanged and <code>end()</code> is returned.</p>
<p>Invalidates all <code>end()</code> subtrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_subtree</td><td>The subtree to copy and adopt as a child. </td></tr>
    <tr><td class="paramname">insert_before</td><td>The child of this node before which to insert the new subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing at the root of the new adopted subtree. </dd></dl>

</div>
</div>
<a id="a43148e9c5506596f5ad5bbe96ab7d8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43148e9c5506596f5ad5bbe96ab7d8cd">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an item from this subtree. </p>
<p>If <code>item</code> is not in the subtree, or if this subtree is not a leaf node, the tree will be unchanged.</p>
<p>Invalidates the iterator to this item, and potentially any <code>end()</code> <code>item_iterator</code>s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to delete; a direct child of this node. </td></tr>
    <tr><td class="paramname">success</td><td>Optional return value pointer to be filled with <code>true</code> if the item was deleted; <code>false</code> if the tree is unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the position of the item just beyond the one that was deleted. This will be <code>items_end()</code> if the deleted item was the last one in its parent node. </dd></dl>

</div>
</div>
<a id="a63697b53c775f64d0cfe962e0ad1b8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63697b53c775f64d0cfe962e0ad1b8c6">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree.html">self_t</a> erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree.html">self_t</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the subtree and its root at <code>child</code>, including all its leaf items. </p>
<p>If <code>child</code> is not a direct child of this node, the tree is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>An optional return value pointer; to be filled with <code>true</code> if the child was deleted; <code>false</code> if the tree is unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the position of the node following the deleted one (which may be <code>end()</code>). </dd></dl>

</div>
</div>
<a id="a9fa6141e19b8f2fd807db44f39bd0292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa6141e19b8f2fd807db44f39bd0292">&#9670;&nbsp;</a></span>insert_child_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree.html">self_t</a> insert_child_node </td>
          <td>(</td>
          <td class="paramtype">const NodeItem &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to insert a new child node at the end of this node's children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>NodeItem to insert into the new node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43bcd0c6dc2c358fa5dffa45eba0784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43bcd0c6dc2c358fa5dffa45eba0784">&#9670;&nbsp;</a></span>insert_child_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree.html">self_t</a> insert_child_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree.html">self_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new tree node under this one, to the left of <code>insert_before</code>. </p>
<p>If this node was previously empty, then its new first child will contain all of its <code>LeafItem</code>s (this is to ensure those leaf items all have a parent which is a leaf node). Otherwise, the new node will be empty of any <code>LeafItem</code>s.</p>
<p>If <code>insert_before</code> is the root node, or if <code>insert_before</code> is not a direct child (or end-child) of this node, then the tree is unaffected and <code>end()</code> is returned. Otherwise, the new node is returned.</p>
<p>Potentially invalidates the <code>end()</code> of other subtrees, or the <code>begin()</code> of this subtree if <code>insert_before</code> is <code>begin()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_before</td><td>A subtree pointing to a child or end-child of this node. </td></tr>
    <tr><td class="paramname">args</td><td>Construction arguments for the new <code>NodeItem</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created node, or <code>end()</code> if the node could not be created. </dd></dl>

</div>
</div>
<a id="ad9e5b2197a9af6c7de917c272febf27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e5b2197a9af6c7de917c272febf27c">&#9670;&nbsp;</a></span>insert_child_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree.html">self_t</a> insert_child_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree.html">self_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeItemIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeItemIterator &amp;&#160;</td>
          <td class="paramname"><em>i_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new tree nodes to the left of <code>insert_before</code>, under this node. Return the first newly created node. </p>
<p>If this node was previously empty, then its new first child will contain all its <code>LeafItem</code>s (this is to ensure those leaf items all have a parent which is a leaf node). All other new nodes will be empty of any <code>LeafItem</code>s.</p>
<p>If <code>insert_before</code> is the root node, or if <code>insert_before</code> is not a child (or end-child) of this node, then the tree is unaffected and <code>end()</code> is returned. Likewise, if no new nodes were inserted, <code>end()</code> is returned. Otherwise, the first new node is returned.</p>
<p>Potentially invalidates the <code>end()</code> of other subtrees, or the <code>begin()</code> of this subtree if <code>insert_before</code> is <code>begin()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_before</td><td>A <a class="el" href="classgeom_1_1_subtree.html" title="A non-const iterator to a subtree.">Subtree</a> pointing to the sibling just after the last new node to be inserted. </td></tr>
    <tr><td class="paramname">i_begin</td><td>A forward iterator to the first NodeItem to be inserted. </td></tr>
    <tr><td class="paramname">i_end</td><td>A forward iterator just beyond the last NodeItem to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first newly created node, or <code>end()</code> if no new nodes were created. </dd></dl>

</div>
</div>
<a id="a3e87236526322b0d94e9b9bffaacf4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e87236526322b0d94e9b9bffaacf4ae">&#9670;&nbsp;</a></span>insert_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> insert_item </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an item under this node. </p>
<p>The new item will be inserted before the item at <code>insert_before</code>, which must belong to this node, otherwise the behavior is undefined. It is permissible for <code>insert_before</code> to be this node's <code>items_begin()</code> or <code>items_end()</code>.</p>
<p>This must be a leaf node; i.e. one with no child nodes, so that placement of the new objects is not abiguous. If this is not a leaf node, the tree is unchanged.</p>
<p>Potentially invalidates the <code>items_end()</code> of other subtrees, or the <code>items_begin()</code> of this subtree if <code>insert_before</code> is <code>items_begin()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_before</td><td>Item belonging to <code>parent</code> which the new items are to be inserted before. </td></tr>
    <tr><td class="paramname">args</td><td>New <code>LeafItem</code> to be inserted, or constructor arguments for the new <code>LeafItem</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first newly placed item if any were placed; <code>items_end()</code> otherwise. </dd></dl>

</div>
</div>
<a id="acd47cfabcde9c76cfb713ad49ea8dbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd47cfabcde9c76cfb713ad49ea8dbeb">&#9670;&nbsp;</a></span>insert_items()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> insert_items </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_subtree.html#a75f4b7955d1888fe47dbc9e682456ac5">item_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>insert_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LeafItemIterator&#160;</td>
          <td class="paramname"><em>begin_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LeafItemIterator &amp;&#160;</td>
          <td class="paramname"><em>end_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t *&#160;</td>
          <td class="paramname"><em>new_item_count</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert multiple leaf items into this node. </p>
<p>The new items will be inserted before the item at <code>insert_before</code>, in the same order. <code>insert_before</code> must belong to the given node, otherwise the behavior is undefined. It is permissible for <code>insert_before</code> to be the node's <code>items_begin()</code> or <code>items_end()</code>.</p>
<p>This must be a leaf node; i.e. one with no child nodes, so that placement of the new objects is not abiguous. If this is not a leaf node, the tree is unchanged.</p>
<p>Invalidates all <code>end()</code> <code>item_iterator</code>s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Leaf node under which the new items will be inserted. </td></tr>
    <tr><td class="paramname">insert_before</td><td>Item belonging to <code>parent</code> which the new items are to be inserted before. </td></tr>
    <tr><td class="paramname">first_item</td><td>Forward iterator to first <code>LeafItem</code> to be inserted. </td></tr>
    <tr><td class="paramname">off_end_item</td><td>Forward iterator just beyond the last <code>LeafItem</code> to be inserted. </td></tr>
    <tr><td class="paramname">new_item_count</td><td>Optional return pointer to receive the count of newly placed objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first newly placed item if any were placed; <code>items_end()</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8d86fc897b16f394375e92efbe5c873b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d86fc897b16f394375e92efbe5c873b">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_subtree.html">self_t</a> split </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split this node into two sibling nodes. </p>
<p>A new node will be created just before this one, under the same parent, and this node's items will be split between them according to the result of <code>compare(item, pivot)</code>: If the comparison is less than zero, the item will be moved to the left (new) node. Otherwise, it will remain in the right (existing) node.</p>
<p>The split node must not be the root, must have no children, and must contain at least two items. If any of these is the case, the tree will not be changed and the off-end node will be returned.</p>
<p>All iterators to the items under this node are invalidated by this operation, as well as potentially any <code>end()</code> <code>item_iterator</code>s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>A callable object <code>compare(a,b)</code> which accepts a <code>LeafItem</code> as its left argument and a <code>P</code> as its right argument, and returns a signed number (negative for <code>a &lt; b</code>, positive for <code>a &gt; b</code>, zero for equality). </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments for the <code>NodeItem</code> object to be assigned to the newly-created (low) node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created sibling, or the off-end node if this is the root node or has child nodes. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>geomc/<a class="el" href="_tree_8h_source.html">Tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 19 2020 13:13:32 for geomc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
