<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geomc: Linalg</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">geomc
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A c++ linear algebra template library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Linalg</div>  </div>
</div><!--header-->
<div class="contents">

<p>Linear algebra functions and classes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matrix.html">Matrix</a></td></tr>
<tr class="memdesc:group__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-related functions and classes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_affine_transform.html">AffineTransform&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine transformation class.  <a href="classgeom_1_1_affine_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_quat.html">Quat&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quaternion class.  <a href="classgeom_1_1_quat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_ray.html">Ray&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgeom_1_1_ray.html" title="Ray class.">Ray</a> class.  <a href="classgeom_1_1_ray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_ray_3_01_t_00_013_01_4.html">Ray&lt; T, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D specialization of <a class="el" href="classgeom_1_1_ray.html" title="Ray class.">Ray</a> class  <a href="classgeom_1_1_ray_3_01_t_00_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_vec.html">Vec&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple of <code>N</code> elements of type <code>T</code>.  <a href="classgeom_1_1_vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_vec_3_01_t_00_012_01_4.html">Vec&lt; T, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D specialization of vector class.  <a href="classgeom_1_1_vec_3_01_t_00_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_vec_3_01_t_00_013_01_4.html">Vec&lt; T, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D specialization of vector class.  <a href="classgeom_1_1_vec_3_01_t_00_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_vec_3_01_t_00_014_01_4.html">Vec&lt; T, 4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4D specialization of vector class.  <a href="classgeom_1_1_vec_3_01_t_00_014_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1a08b60461059eecc146451e65370606"><td class="memTemplParams" colspan="2">template&lt;typename T , index_t N&gt; </td></tr>
<tr class="memitem:ga1a08b60461059eecc146451e65370606"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga1a08b60461059eecc146451e65370606">orthogonal</a> (const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; v[N-1])</td></tr>
<tr class="separator:ga1a08b60461059eecc146451e65370606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30df286717929ce22deabe6b52ae9d24"><td class="memTemplParams" colspan="2">template&lt;typename T , index_t N&gt; </td></tr>
<tr class="memitem:ga30df286717929ce22deabe6b52ae9d24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga30df286717929ce22deabe6b52ae9d24">nullspace</a> (const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; bases[], index_t n, <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; null_basis[])</td></tr>
<tr class="separator:ga30df286717929ce22deabe6b52ae9d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f1b41485890042afd5512975ab88be"><td class="memTemplParams" colspan="2">template&lt;typename T , index_t N&gt; </td></tr>
<tr class="memitem:ga03f1b41485890042afd5512975ab88be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga03f1b41485890042afd5512975ab88be">orthogonalize</a> (<a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; basis[], index_t n)</td></tr>
<tr class="separator:ga03f1b41485890042afd5512975ab88be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15114a19ef15055cf894fd8e5bf3d962"><td class="memTemplParams" colspan="2">template&lt;typename T , index_t N&gt; </td></tr>
<tr class="memitem:ga15114a19ef15055cf894fd8e5bf3d962"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga15114a19ef15055cf894fd8e5bf3d962">orthonormalize</a> (<a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; basis[], index_t n)</td></tr>
<tr class="separator:ga15114a19ef15055cf894fd8e5bf3d962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4833f1fc9d738db86ea5a6ff9339426"><td class="memTemplParams" colspan="2">template&lt;typename T , bool RowMajor&gt; </td></tr>
<tr class="memitem:gaa4833f1fc9d738db86ea5a6ff9339426"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#gaa4833f1fc9d738db86ea5a6ff9339426">cholesky</a> (T *m, index_t n)</td></tr>
<tr class="separator:gaa4833f1fc9d738db86ea5a6ff9339426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6cd9834a4c2f34896398e215733f9e5"><td class="memTemplParams" colspan="2">template&lt;typename T , index_t M, index_t N&gt; </td></tr>
<tr class="memitem:gad6cd9834a4c2f34896398e215733f9e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#gad6cd9834a4c2f34896398e215733f9e5">cholesky</a> (<a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix</a>&lt; T, M, N &gt; *m)</td></tr>
<tr class="separator:gad6cd9834a4c2f34896398e215733f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44a35d89fa24199ace1e157f0cd3961"><td class="memTemplParams" colspan="2">template&lt;typename T , bool RowMajor = true&gt; </td></tr>
<tr class="memitem:gae44a35d89fa24199ace1e157f0cd3961"><td class="memTemplItemLeft" align="right" valign="top">index_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#gae44a35d89fa24199ace1e157f0cd3961">decomp_lup</a> (T *m, index_t rows, index_t cols, index_t *reorder, bool *swap_parity)</td></tr>
<tr class="separator:gae44a35d89fa24199ace1e157f0cd3961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c6c7a476d476978a2bc55e52c83634"><td class="memTemplParams" colspan="2">template&lt;typename T , bool RowMajor = true&gt; </td></tr>
<tr class="memitem:ga13c6c7a476d476978a2bc55e52c83634"><td class="memTemplItemLeft" align="right" valign="top">index_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga13c6c7a476d476978a2bc55e52c83634">decomp_plu</a> (T *m, index_t rows, index_t cols, index_t *reorder, bool *swap_parity)</td></tr>
<tr class="separator:ga13c6c7a476d476978a2bc55e52c83634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1050f12083b401f536781017151ee8"><td class="memTemplParams" colspan="2">template&lt;typename T , bool RowMajor = true&gt; </td></tr>
<tr class="memitem:ga4a1050f12083b401f536781017151ee8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga4a1050f12083b401f536781017151ee8">linear_solve_lup</a> (const T *lup, const index_t *p, index_t n, T *x, const T *b, index_t skip=0)</td></tr>
<tr class="separator:ga4a1050f12083b401f536781017151ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9881e913e0cfae528ed593459966240b"><td class="memTemplParams" colspan="2">template&lt;typename T , bool RowMajor = true&gt; </td></tr>
<tr class="memitem:ga9881e913e0cfae528ed593459966240b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#ga9881e913e0cfae528ed593459966240b">linear_solve_lu</a> (const T *lu, index_t n, T *x, const T *b, index_t skip=0)</td></tr>
<tr class="separator:ga9881e913e0cfae528ed593459966240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd350d4fbaac325634ebd55a2c196251"><td class="memTemplParams" colspan="2">template&lt;typename T , bool RowMajor = true&gt; </td></tr>
<tr class="memitem:gadd350d4fbaac325634ebd55a2c196251"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#gadd350d4fbaac325634ebd55a2c196251">linear_solve</a> (T *m, index_t n, T *x, const T *b, index_t skip=0)</td></tr>
<tr class="separator:gadd350d4fbaac325634ebd55a2c196251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d2e86bccb2b6a30001a6e29c4a4b59"><td class="memTemplParams" colspan="2">template&lt;typename T , index_t N&gt; </td></tr>
<tr class="memitem:gaa5d2e86bccb2b6a30001a6e29c4a4b59"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linalg.html#gaa5d2e86bccb2b6a30001a6e29c4a4b59">linear_solve</a> (<a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; *bases, <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; *x, const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; &amp;b, index_t skip=0)</td></tr>
<tr class="separator:gaa5d2e86bccb2b6a30001a6e29c4a4b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Linear algebra functions and classes. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa4833f1fc9d738db86ea5a6ff9339426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4833f1fc9d738db86ea5a6ff9339426">&#9670;&nbsp;</a></span>cholesky() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::cholesky </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform an in-place Cholesky decomposition on the given square positive-definite matrix <code>A</code>, producing a lower-triangular matrix <code>M</code> such that <code>(M * M</code><sup>T</sup><code>) = A</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">RowMajor</td><td>Whether the elements in <code>m</code> are arranged in row-major (true) or column-major (false) order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The elements of the matrix to be decomposed. </td></tr>
    <tr><td class="paramname">n</td><td>The number of rows/columns in the matrix to be decomposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the decomposition could be completed; false if the matrix was not positive-definite or ill-conditioned. </dd></dl>

</div>
</div>
<a id="gad6cd9834a4c2f34896398e215733f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6cd9834a4c2f34896398e215733f9e5">&#9670;&nbsp;</a></span>cholesky() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::cholesky </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix</a>&lt; T, M, N &gt; *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform an in-place Cholesky decomposition on the given square positive-definite matrix <code>A</code>, producing a lower-triangular matrix <code>M</code> such that <code>(M * M</code><sup>T</sup><code>) = A</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A square positive-definite matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the matrix is not square, not positive-definite, or could not be decomposed due to ill-conditioning; <code>true</code> if the decomposition was completed successfully. </dd></dl>

</div>
</div>
<a id="gae44a35d89fa24199ace1e157f0cd3961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae44a35d89fa24199ace1e157f0cd3961">&#9670;&nbsp;</a></span>decomp_lup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">index_t geom::decomp_lup </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t *&#160;</td>
          <td class="paramname"><em>reorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>swap_parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LU decomposition, pivoting columns.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the matrix. </td></tr>
    <tr><td class="paramname">RowMajor</td><td>Whether the layout of the matrix is row-major (<code>true</code>) or column-major (<code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array of elements to decompose. </td></tr>
    <tr><td class="paramname">rows</td><td>Number of rows in <code>m</code>. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in <code>m</code>. </td></tr>
    <tr><td class="paramname">reorder</td><td>Array with space for <code>cols</code> elements to be filled with the column source indexes. </td></tr>
    <tr><td class="paramname">swap_parity</td><td>Whether an odd number of column-swaps was performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of degenerate columns discovered. </dd></dl>

</div>
</div>
<a id="ga13c6c7a476d476978a2bc55e52c83634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13c6c7a476d476978a2bc55e52c83634">&#9670;&nbsp;</a></span>decomp_plu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">index_t geom::decomp_plu </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t *&#160;</td>
          <td class="paramname"><em>reorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>swap_parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LU decomposition, pivoting rows.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the matrix. </td></tr>
    <tr><td class="paramname">RowMajor</td><td>Whether the layout of the matrix is row-major (<code>true</code>) or column-major (<code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array of elements to decompose. </td></tr>
    <tr><td class="paramname">rows</td><td>Number of rows in <code>m</code>. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in <code>m</code>. </td></tr>
    <tr><td class="paramname">reorder</td><td>Array with space for <code>rows</code> elements to be filled with the row source indexes. </td></tr>
    <tr><td class="paramname">swap_parity</td><td>Whether an odd number of row-swaps was performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of degenerate rows discovered. </dd></dl>

</div>
</div>
<a id="gadd350d4fbaac325634ebd55a2c196251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd350d4fbaac325634ebd55a2c196251">&#9670;&nbsp;</a></span>linear_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::linear_solve </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>skip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Solve a system of linear equations <code>Mx = b</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the matrix. </td></tr>
    <tr><td class="paramname">RowMajor</td><td>Whether the layout of the matrix is row-major (<code>true</code>) or column-major (<code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A buffer of elements in the matrix <code>M</code>. This array will be altered during the solution process, so pass a copy if the original needs to remain unchanged. </td></tr>
    <tr><td class="paramname">n</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">x</td><td>The solution vector of <code>N</code> elements to be filled. </td></tr>
    <tr><td class="paramname">b</td><td>A vector of <code>N</code> elements. </td></tr>
    <tr><td class="paramname">skip</td><td>How many variables, in order from the first, to skip solving for. If greater than 0, the corresponding variables within <code>x</code> will contain nonsense values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the system is not degenerate. </dd></dl>

</div>
</div>
<a id="gaa5d2e86bccb2b6a30001a6e29c4a4b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d2e86bccb2b6a30001a6e29c4a4b59">&#9670;&nbsp;</a></span>linear_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::linear_solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; *&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>skip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a vector <code>b</code> in terms of the basis vectors in <code>bases</code>; return <code>x</code> such that <code>sum(bases[i] * x[i]) = b</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bases</td><td>An array of <code>N</code> basis vectors. The contents of this array will be altered during the solution process, so pass a copy if the original array needs to remain unchanged. </td></tr>
    <tr><td class="paramname">x</td><td>The solution vector to be filled. </td></tr>
    <tr><td class="paramname">b</td><td>A vector. </td></tr>
    <tr><td class="paramname">skip</td><td>How many variables, in order from the first, to skip solving for. If greater than 0, the corresponding variables within <code>x</code> will contain nonsense values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the system is not degenerate. </dd></dl>

</div>
</div>
<a id="ga9881e913e0cfae528ed593459966240b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9881e913e0cfae528ed593459966240b">&#9670;&nbsp;</a></span>linear_solve_lu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::linear_solve_lu </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>lu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>skip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve a system of linear equations <code>LUx = b</code>, without a permutation map.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the matrix. </td></tr>
    <tr><td class="paramname">RowMajor</td><td>Whether the layout of the matrix is row-major (<code>true</code>) or column-major (<code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lup</td><td>An <code>n x n</code> LU-decomposed matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of rows and columns in the matrix. </td></tr>
    <tr><td class="paramname">x</td><td>The solution vector of <code>n</code> elements to be filled. </td></tr>
    <tr><td class="paramname">b</td><td>A vector of <code>n</code> elements. </td></tr>
    <tr><td class="paramname">skip</td><td>How many variables, in order from the first, to skip solving for. If greater than 0, the corresponding variables within <code>x</code> will contain nonsense values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a1050f12083b401f536781017151ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a1050f12083b401f536781017151ee8">&#9670;&nbsp;</a></span>linear_solve_lup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::linear_solve_lup </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>lup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const index_t *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>skip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve a system of linear equations <code>LUx = Pb</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the matrix. </td></tr>
    <tr><td class="paramname">RowMajor</td><td>Whether the layout of the matrix is row-major (<code>true</code>) or column-major (<code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lup</td><td>An <code>n x n</code> LUP-decomposed matrix. </td></tr>
    <tr><td class="paramname">p</td><td>The permutation array filled by <code><a class="el" href="group__linalg.html#gae44a35d89fa24199ace1e157f0cd3961">decomp_lup()</a></code>. </td></tr>
    <tr><td class="paramname">n</td><td>The number of rows and columns in the matrix. </td></tr>
    <tr><td class="paramname">x</td><td>The solution vector of <code>n</code> elements to be filled. </td></tr>
    <tr><td class="paramname">b</td><td>A vector of <code>n</code> elements. </td></tr>
    <tr><td class="paramname">skip</td><td>How many variables, in order from the first, to skip solving for. If greater than 0, the corresponding variables within <code>x</code> will contain nonsense values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30df286717929ce22deabe6b52ae9d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30df286717929ce22deabe6b52ae9d24">&#9670;&nbsp;</a></span>nullspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::nullspace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>bases</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>null_basis</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the null space of a vector basis.</p>
<p><code>bases</code> and <code>null_basis</code> may alias each other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bases</td><td>Array of <code>n</code> linearly independent basis vectors. </td></tr>
    <tr><td class="paramname">n</td><td>Number of basis vectors in the array. </td></tr>
    <tr><td class="paramname">null_basis</td><td>Array with space for <code>N - n</code> output bases, whose dot products with the inputs are all zero. The elements of this array will not necessarily be orthogonal to each other. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a08b60461059eecc146451e65370606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a08b60461059eecc146451e65370606">&#9670;&nbsp;</a></span>orthogonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt;T,N&gt; geom::orthogonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>v</em>[N-1]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector orthogonal to the given <code>N-1</code> vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Array of <code>N-1</code> basis vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector normal to all the members of <code>v</code>. </dd></dl>

</div>
</div>
<a id="ga03f1b41485890042afd5512975ab88be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03f1b41485890042afd5512975ab88be">&#9670;&nbsp;</a></span>orthogonalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::orthogonalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>basis</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the Gram-Schmidt process to orthogonalize a set of basis vectors. The first basis vector will not change. The remaining vectors may be of arbitrary magnitude, but will be mutually orthogonal to each other and to the first vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>Set of <code>n</code> bases vectors. </td></tr>
    <tr><td class="paramname">n</td><td>Number of basis vectors between 0 and <code>N</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15114a19ef15055cf894fd8e5bf3d962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15114a19ef15055cf894fd8e5bf3d962">&#9670;&nbsp;</a></span>orthonormalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::orthonormalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgeom_1_1_vec.html">Vec</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>basis</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the Gram-Schmidt process to orthonormalize a set of basis vectors. The first basis vector will not change direction. All vectors will be made mutually orthogonal and unit length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>Set of <code>n</code> bases vectors. </td></tr>
    <tr><td class="paramname">n</td><td>Number of basis vectors between 0 and <code>N</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 14 2020 19:06:39 for geomc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
